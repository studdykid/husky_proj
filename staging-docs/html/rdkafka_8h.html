<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>librdkafka: src/rdkafka.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">librdkafka
   </div>
   <div id="projectbrief">The Apache Kafka C/C++ client library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rdkafka.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Apache Kafka C/C++ consumer and producer client library.  
<a href="#details">More...</a></p>

<p><a href="rdkafka_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topic+Partition place holder.  <a href="structrd__kafka__topic__partition__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A growable list of Topic+Partitions.  <a href="structrd__kafka__topic__partition__list__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__metadata__broker__t.html">rd_kafka_metadata_broker_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__metadata__partition__t.html">rd_kafka_metadata_partition_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__metadata__topic__t.html">rd_kafka_metadata_topic_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__metadata__t.html">rd_kafka_metadata_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa2e242fb8620a32b650a40575bc7f98e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e">RD_KAFKA_VERSION</a>&#160;&#160;&#160;0x000900ff</td></tr>
<tr class="memdesc:aa2e242fb8620a32b650a40575bc7f98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">librdkafka version  <a href="#aa2e242fb8620a32b650a40575bc7f98e">More...</a><br/></td></tr>
<tr class="separator:aa2e242fb8620a32b650a40575bc7f98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed25dba90c47adc8ae51d098dca2aed9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aed25dba90c47adc8ae51d098dca2aed9">RD_KAFKA_DEBUG_CONTEXTS</a>&#160;&#160;&#160;&quot;all,generic,broker,topic,metadata,producer,queue,msg,protocol,cgrp,security,fetch&quot;</td></tr>
<tr class="memdesc:aed25dba90c47adc8ae51d098dca2aed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported debug contexts. (compile time)  <a href="#aed25dba90c47adc8ae51d098dca2aed9">More...</a><br/></td></tr>
<tr class="separator:aed25dba90c47adc8ae51d098dca2aed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3002d1858385de283ea004893e352863"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3002d1858385de283ea004893e352863">RD_KAFKA_PARTITION_UA</a>&#160;&#160;&#160;((int32_t)-1)</td></tr>
<tr class="memdesc:a3002d1858385de283ea004893e352863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unassigned partition.  <a href="#a3002d1858385de283ea004893e352863">More...</a><br/></td></tr>
<tr class="separator:a3002d1858385de283ea004893e352863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dc6dd93c16e3aac9b89804c4817fba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>RD_KAFKA_OFFSET_BEGINNING</b></td></tr>
<tr class="separator:a32dc6dd93c16e3aac9b89804c4817fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7aaaf16e5bd7c0a8a8cb014275c3e06"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>RD_KAFKA_OFFSET_END</b></td></tr>
<tr class="separator:aa7aaaf16e5bd7c0a8a8cb014275c3e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727dc7080140da43adbd5d0b170d49be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>RD_KAFKA_OFFSET_STORED</b></td></tr>
<tr class="separator:a727dc7080140da43adbd5d0b170d49be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810f79c81e164e8d19c4275f7745246e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a810f79c81e164e8d19c4275f7745246e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RD_KAFKA_OFFSET_TAIL_BASE</b>&#160;&#160;&#160;-2000 /* internal: do not use */</td></tr>
<tr class="separator:a810f79c81e164e8d19c4275f7745246e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26a2522ce2d8ef8ce6c0235e8cfd409"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae26a2522ce2d8ef8ce6c0235e8cfd409"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RD_KAFKA_OFFSET_TAIL</b>(CNT)&#160;&#160;&#160;(RD_KAFKA_OFFSET_TAIL_BASE - (CNT))</td></tr>
<tr class="separator:ae26a2522ce2d8ef8ce6c0235e8cfd409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21be13f8a4cb1d5aff01419f333e5ea7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a21be13f8a4cb1d5aff01419f333e5ea7">RD_KAFKA_MSG_F_FREE</a>&#160;&#160;&#160;0x1  /* Delegate freeing of payload to rdkafka. */</td></tr>
<tr class="separator:a21be13f8a4cb1d5aff01419f333e5ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7468ab0ece73cc9cb6253a3dcfe702d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7468ab0ece73cc9cb6253a3dcfe702d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RD_KAFKA_MSG_F_COPY</b>&#160;&#160;&#160;0x2  /* rdkafka will make a copy of the payload. */</td></tr>
<tr class="separator:ad7468ab0ece73cc9cb6253a3dcfe702d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac6f9c3cb01cbaf3013689c4f2731b831"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831">rd_kafka_type_t</a> { <a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831ae6134e8d67bee67bfe5e90783f3b9dc8">RD_KAFKA_PRODUCER</a>, 
<a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831abdc1bc1d648fb12ee3f7d42de732e049">RD_KAFKA_CONSUMER</a>
 }</td></tr>
<tr class="memdesc:ac6f9c3cb01cbaf3013689c4f2731b831"><td class="mdescLeft">&#160;</td><td class="mdescRight">rd_kafka_t handle type.  <a href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831">More...</a><br/></td></tr>
<tr class="separator:ac6f9c3cb01cbaf3013689c4f2731b831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03509bab51072c72a8dcf52337e6d5cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> { <br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba2142df2480425e88d9d96b1b08cc7c67">RD_KAFKA_RESP_ERR__BEGIN</a> = -200, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba807f99673a16c6dfc2d6711a142fdf63">RD_KAFKA_RESP_ERR__BAD_MSG</a> = -199, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba83f21df6d9e4919fa6f63f4978d92e31">RD_KAFKA_RESP_ERR__BAD_COMPRESSION</a> = -198, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba9701b1e8dbfd8514773837924607985d">RD_KAFKA_RESP_ERR__DESTROY</a> = -197, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba499a09426c7317e0c8030be5bfadd6a2">RD_KAFKA_RESP_ERR__FAIL</a> = -196, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaa2e905024b42d56f177547ef2c6921f2">RD_KAFKA_RESP_ERR__TRANSPORT</a> = -195, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbad854e2c94bb5b92e83cdbe5d1b1a98ab">RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE</a> = -194, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba86ca698f5d4d99a0d61b0ec62c6ab093">RD_KAFKA_RESP_ERR__RESOLVE</a> = -193, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbacb94a826892b8fef52de2c326f765172">RD_KAFKA_RESP_ERR__MSG_TIMED_OUT</a> = -192, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaffd61f12a5298f508039a9e2521752a5">RD_KAFKA_RESP_ERR__PARTITION_EOF</a> = -191, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba1703a6690b6278c4ce60a7745d81c435">RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION</a> = -190, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba184f6fcda3fe1f6549c45f621dc456bf">RD_KAFKA_RESP_ERR__FS</a> = -189, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbacc9b54e879dba9f6ed3c6e4492a4ae9e">RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC</a> = -188, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbadf1a1cc2d9244d10b5d9b2176da1a7b1">RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN</a> = -187, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba44458ff21ab957663118decae3fe0a31">RD_KAFKA_RESP_ERR__INVALID_ARG</a> = -186, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba191a3d68aab046a25af5e861a5ce394e">RD_KAFKA_RESP_ERR__TIMED_OUT</a> = -185, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba8614bce6b6367c95e05003ed953abefa">RD_KAFKA_RESP_ERR__QUEUE_FULL</a> = -184, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba35e614340fa0417a954a94d9ed252be3">RD_KAFKA_RESP_ERR__ISR_INSUFF</a> = -183, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbad6b23970e00b4575556e8bf6669b1907">RD_KAFKA_RESP_ERR__NODE_UPDATE</a> = -182, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbafa666e504c1c4db6132bb8cc62789bd7">RD_KAFKA_RESP_ERR__SSL</a> = -181, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaff33cdcf5c414f862d30bfc971d9b883">RD_KAFKA_RESP_ERR__WAIT_COORD</a> = -180, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba34f3842df468d18d83eaf06fcb1ec133">RD_KAFKA_RESP_ERR__UNKNOWN_GROUP</a> = -179, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba3aa91f47659cd8db6e526d61bd801bb0">RD_KAFKA_RESP_ERR__IN_PROGRESS</a> = -178, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba7e8c91550c7f80e3bde03d2e2a26a13f">RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS</a> = -177, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba564de373d65dea2640f879b8f38032ba">RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION</a> = -176, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba4eab145a6f57f455bdde22cb94b61e90">RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS</a> = -175, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba52a7ba59b755f419beec0433cb1633bb">RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS</a> = -174, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbab7a5dd3646ae093462cd3bb7add5c591">RD_KAFKA_RESP_ERR__CONFLICT</a> = -173, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba6953cd96832fca9dab355a87dd83ac0d">RD_KAFKA_RESP_ERR__STATE</a> = -172, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba8c92444502a2e12e78e34c293bcdd341">RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL</a> = -171, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba8a4196c480d8dde72c14c390fe94b113">RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED</a> = -170, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba87e67feaf9a884055ca195ece3ccf1c4">RD_KAFKA_RESP_ERR__AUTHENTICATION</a> = -169, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbada22593237070471d4ce1de595d1a0ae">RD_KAFKA_RESP_ERR__NO_OFFSET</a> = -168, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaebda7d93e71b33ea682f2cdb2d025c0c">RD_KAFKA_RESP_ERR__END</a> = -100, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbafd4f4e867c50ec320e86871b98b7b15e">RD_KAFKA_RESP_ERR_UNKNOWN</a> = -1, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaeb15f812641343033e3939df4adfff0a">RD_KAFKA_RESP_ERR_NO_ERROR</a> = 0, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaab466ebc9f9efcdbedfef4e57449adf4">RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE</a> = 1, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbadaaa397721f1566aa1befbb42635c6c9">RD_KAFKA_RESP_ERR_INVALID_MSG</a> = 2, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba22f2b9f295640b43bbd20b064931eaa4">RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART</a> = 3, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba4a78c95be9dce44441151db0f064939e">RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE</a> = 4, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba1b8fa864f8174e650a362d6c85c4acac">RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE</a> = 5, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba48f7ea11514f0d02c090a0bf52deabb8">RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION</a> = 6, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba1944ffe5311ce97d4f71133efd5f745f">RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT</a> = 7, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba7021ad7d7486a4a33e19df226908f6f4">RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE</a> = 8, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba550f9d64d5e2d05c61b5f18942832854">RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE</a> = 9, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba2c5f25f8d58662c06485884c62ccd728">RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE</a> = 10, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba901383ac11a5068e5cfa64fe0899ef42">RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH</a> = 11, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbad1ace41b4944aa8510d001cc0750af3d">RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE</a> = 12, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba24a154a4fd4b62b7a7fa77b816561c49">RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION</a> = 13, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba837e05b8dc24415d0cdd24fa90c94c2b">RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS</a> = 14, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba4b2032a44b39cfcf79af6d38cfee53d6">RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE</a> = 15, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbae3cca426eb84d8c987fcd22d93e3b042">RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP</a> = 16, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaffe696a1bb54ec33b8d258a71d138630">RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION</a> = 17, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba2427070db08c0dbf603d7a439ecafa4e">RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE</a> = 18, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba963396ec3f0141e7cd64eb9103ba025a">RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS</a> = 19, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba3c6bd5bd0a338857481157ad58701285">RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND</a> = 20, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba1bcf9b14d3109e0906710f3fedf6bfa0">RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS</a> = 21, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba7ef65ef4b7e4883d37f07edb2b9299cf">RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION</a> = 22, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba3d611434978ee6c5d1e2c031eae22851">RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL</a> = 23, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba617af6d0a3be8be217a6d4097fe08d93">RD_KAFKA_RESP_ERR_INVALID_GROUP_ID</a> = 24, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba98ba2fb36473df8aa20eece119b5c371">RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID</a> = 25, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbacbf57dcb89cbe4e8109009235c3a38a3">RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT</a> = 26, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbafacbf6cd012723e9deeffdbedb086c34">RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS</a> = 27, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbabce6dddfb9449a93d89f5175259b01f5">RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE</a> = 28, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbac3ca8f351f7f49bc644360d70def9d15">RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED</a> = 29, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaf6a3717285b4de6d098778d5abff62d3">RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED</a> = 30, 
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba91be303afca8631793ae36cd7fa5eb9b">RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED</a> = 31
<br/>
 }</td></tr>
<tr class="memdesc:a03509bab51072c72a8dcf52337e6d5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes.  <a href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">More...</a><br/></td></tr>
<tr class="separator:a03509bab51072c72a8dcf52337e6d5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8306a08e59e8e2cbc6abdb84f9689f4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a> { <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4aa1a1dc8e18c730866165853ad819054e">RD_KAFKA_CONF_UNKNOWN</a> = -2, 
<a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4a4461e999ca6c9837a9265dad6f2a0d1e">RD_KAFKA_CONF_INVALID</a> = -1, 
<a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4a12343fa082ab52164a17130d6b0d0f5b">RD_KAFKA_CONF_OK</a> = 0
 }</td></tr>
<tr class="memdesc:ad8306a08e59e8e2cbc6abdb84f9689f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main configuration property interface.  <a href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">More...</a><br/></td></tr>
<tr class="separator:ad8306a08e59e8e2cbc6abdb84f9689f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a83e363606ef2da2e91b7429b229dbc8e"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a83e363606ef2da2e91b7429b229dbc8e">rd_kafka_version</a> (void)</td></tr>
<tr class="memdesc:a83e363606ef2da2e91b7429b229dbc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the librdkafka version as integer.  <a href="#a83e363606ef2da2e91b7429b229dbc8e">More...</a><br/></td></tr>
<tr class="separator:a83e363606ef2da2e91b7429b229dbc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc60434083686fd8e379a905652d34a"><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0cc60434083686fd8e379a905652d34a">rd_kafka_version_str</a> (void)</td></tr>
<tr class="memdesc:a0cc60434083686fd8e379a905652d34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the librdkafka version as string.  <a href="#a0cc60434083686fd8e379a905652d34a">More...</a><br/></td></tr>
<tr class="separator:a0cc60434083686fd8e379a905652d34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adece97d3cbdd6ca936df5b0663118c45"><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#adece97d3cbdd6ca936df5b0663118c45">rd_kafka_get_debug_contexts</a> (void)</td></tr>
<tr class="memdesc:adece97d3cbdd6ca936df5b0663118c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve supported debug contexts for use with the <code>"debug"</code> configuration property. (runtime)  <a href="#adece97d3cbdd6ca936df5b0663118c45">More...</a><br/></td></tr>
<tr class="separator:adece97d3cbdd6ca936df5b0663118c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bfc925e8d63851511b88a1cee94d6d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab7bfc925e8d63851511b88a1cee94d6d">rd_kafka_err2str</a> (<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err)</td></tr>
<tr class="memdesc:ab7bfc925e8d63851511b88a1cee94d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a human readable representation of a kafka error.  <a href="#ab7bfc925e8d63851511b88a1cee94d6d">More...</a><br/></td></tr>
<tr class="separator:ab7bfc925e8d63851511b88a1cee94d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c7d1faaa534befeedf23b55a88a40f"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a99c7d1faaa534befeedf23b55a88a40f">rd_kafka_errno2err</a> (int errnox)</td></tr>
<tr class="memdesc:a99c7d1faaa534befeedf23b55a88a40f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the system errno value <code>errnox</code> to a rd_kafka_resp_err_t error code upon failure from the following functions:  <a href="#a99c7d1faaa534befeedf23b55a88a40f">More...</a><br/></td></tr>
<tr class="separator:a99c7d1faaa534befeedf23b55a88a40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb87d24333b6ad5a7415b06882f06b2a"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <br class="typebreak"/>
<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#afb87d24333b6ad5a7415b06882f06b2a">rd_kafka_topic_partition_list_new</a> (int size)</td></tr>
<tr class="memdesc:afb87d24333b6ad5a7415b06882f06b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new list/vector Topic+Partition container.  <a href="#afb87d24333b6ad5a7415b06882f06b2a">More...</a><br/></td></tr>
<tr class="separator:afb87d24333b6ad5a7415b06882f06b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0ab2640e5e96113ce108ab78f475d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c0ab2640e5e96113ce108ab78f475d0"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0c0ab2640e5e96113ce108ab78f475d0">rd_kafka_topic_partition_list_destroy</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rkparlist)</td></tr>
<tr class="memdesc:a0c0ab2640e5e96113ce108ab78f475d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all resources used by the list and the list itself. <br/></td></tr>
<tr class="separator:a0c0ab2640e5e96113ce108ab78f475d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123ce30e08b31d4ff0fcf6ebe876173d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <br class="typebreak"/>
<a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a123ce30e08b31d4ff0fcf6ebe876173d">rd_kafka_topic_partition_list_add</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rktparlist, const char *topic, int32_t partition)</td></tr>
<tr class="memdesc:a123ce30e08b31d4ff0fcf6ebe876173d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add topic+partition to list.  <a href="#a123ce30e08b31d4ff0fcf6ebe876173d">More...</a><br/></td></tr>
<tr class="separator:a123ce30e08b31d4ff0fcf6ebe876173d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6365695de425e7866ddd0c59d704111b"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6365695de425e7866ddd0c59d704111b">rd_kafka_topic_partition_list_add_range</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rktparlist, const char *topic, int32_t start, int32_t stop)</td></tr>
<tr class="memdesc:a6365695de425e7866ddd0c59d704111b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add range of partitions from <code>start</code> to <code>stop</code> inclusive.  <a href="#a6365695de425e7866ddd0c59d704111b">More...</a><br/></td></tr>
<tr class="separator:a6365695de425e7866ddd0c59d704111b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fd3f8c00ffbd0ea740a638dd0a95f7"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <br class="typebreak"/>
<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a66fd3f8c00ffbd0ea740a638dd0a95f7">rd_kafka_topic_partition_list_copy</a> (const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *src)</td></tr>
<tr class="memdesc:a66fd3f8c00ffbd0ea740a638dd0a95f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of an existing list.  <a href="#a66fd3f8c00ffbd0ea740a638dd0a95f7">More...</a><br/></td></tr>
<tr class="separator:a66fd3f8c00ffbd0ea740a638dd0a95f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e0c519209d1afe9e29468f766c1c24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35e0c519209d1afe9e29468f766c1c24"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a35e0c519209d1afe9e29468f766c1c24">rd_kafka_message_destroy</a> (<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage)</td></tr>
<tr class="memdesc:a35e0c519209d1afe9e29468f766c1c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees resources for <code>rkmessage</code> and hands ownership back to rdkafka. <br/></td></tr>
<tr class="separator:a35e0c519209d1afe9e29468f766c1c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bf740feec09959d5ab7ac10f5f0901"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84bf740feec09959d5ab7ac10f5f0901"></a>
static __inline const char <br class="typebreak"/>
*RD_UNUSED&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a84bf740feec09959d5ab7ac10f5f0901">rd_kafka_message_errstr</a> (const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage)</td></tr>
<tr class="memdesc:a84bf740feec09959d5ab7ac10f5f0901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error string for an errored <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> or NULL if there was no error. <br/></td></tr>
<tr class="separator:a84bf740feec09959d5ab7ac10f5f0901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7459bd22e8cfa81aa8c2480a4a0304c"><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_conf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c">rd_kafka_conf_new</a> (void)</td></tr>
<tr class="memdesc:aa7459bd22e8cfa81aa8c2480a4a0304c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create configuration object.  <a href="#aa7459bd22e8cfa81aa8c2480a4a0304c">More...</a><br/></td></tr>
<tr class="separator:aa7459bd22e8cfa81aa8c2480a4a0304c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3669dacf78c5c0eb536d65cb45d0491"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3669dacf78c5c0eb536d65cb45d0491"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#af3669dacf78c5c0eb536d65cb45d0491">rd_kafka_conf_destroy</a> (rd_kafka_conf_t *conf)</td></tr>
<tr class="memdesc:af3669dacf78c5c0eb536d65cb45d0491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a conf object. <br/></td></tr>
<tr class="separator:af3669dacf78c5c0eb536d65cb45d0491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbfe15c6978ff09870e82cb524c673d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_conf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8cbfe15c6978ff09870e82cb524c673d">rd_kafka_conf_dup</a> (const rd_kafka_conf_t *conf)</td></tr>
<tr class="separator:a8cbfe15c6978ff09870e82cb524c673d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1b319278333e8cdee9442da7f135e8"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abb1b319278333e8cdee9442da7f135e8">rd_kafka_conf_set</a> (rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size)</td></tr>
<tr class="separator:abb1b319278333e8cdee9442da7f135e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075b15c4141784fdc271de217005a41f"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a075b15c4141784fdc271de217005a41f">rd_kafka_conf_set_dr_cb</a> (rd_kafka_conf_t *conf, void(*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, void *opaque, void *msg_opaque))</td></tr>
<tr class="separator:a075b15c4141784fdc271de217005a41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c9946aee26e10de2661fcf2242ea8a"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac1c9946aee26e10de2661fcf2242ea8a">rd_kafka_conf_set_dr_msg_cb</a> (rd_kafka_conf_t *conf, void(*dr_msg_cb)(rd_kafka_t *rk, const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque))</td></tr>
<tr class="separator:ac1c9946aee26e10de2661fcf2242ea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65eaf45e9b26bcb085f4651634ce06a5"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a65eaf45e9b26bcb085f4651634ce06a5">rd_kafka_conf_set_consume_cb</a> (rd_kafka_conf_t *conf, void(*consume_cb)(<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque))</td></tr>
<tr class="separator:a65eaf45e9b26bcb085f4651634ce06a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10db731dc1a295bd9884e4f8cb199311"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a10db731dc1a295bd9884e4f8cb199311">rd_kafka_conf_set_rebalance_cb</a> (rd_kafka_conf_t *conf, void(*rebalance_cb)(rd_kafka_t *rk, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *partitions, void *opaque))</td></tr>
<tr class="separator:a10db731dc1a295bd9884e4f8cb199311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab8bb9e8d8cdd5906f9e060b506f2eb"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a1ab8bb9e8d8cdd5906f9e060b506f2eb">rd_kafka_conf_set_offset_commit_cb</a> (rd_kafka_conf_t *conf, void(*offset_commit_cb)(rd_kafka_t *rk, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, void *opaque))</td></tr>
<tr class="separator:a1ab8bb9e8d8cdd5906f9e060b506f2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace721ef3b7c22d0c111ec747ef039a90"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ace721ef3b7c22d0c111ec747ef039a90">rd_kafka_conf_set_error_cb</a> (rd_kafka_conf_t *conf, void(*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque))</td></tr>
<tr class="separator:ace721ef3b7c22d0c111ec747ef039a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04160826ad039d42c10edec456163fa7"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a04160826ad039d42c10edec456163fa7">rd_kafka_conf_set_throttle_cb</a> (rd_kafka_conf_t *conf, void(*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque))</td></tr>
<tr class="separator:a04160826ad039d42c10edec456163fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ade2ca41f32eb82c6f7e3d4acbe19f"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a06ade2ca41f32eb82c6f7e3d4acbe19f">rd_kafka_conf_set_log_cb</a> (rd_kafka_conf_t *conf, void(*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf))</td></tr>
<tr class="separator:a06ade2ca41f32eb82c6f7e3d4acbe19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597d00432e3ca22174d18e7e348fb766"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a597d00432e3ca22174d18e7e348fb766">rd_kafka_conf_set_stats_cb</a> (rd_kafka_conf_t *conf, int(*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque))</td></tr>
<tr class="separator:a597d00432e3ca22174d18e7e348fb766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0467a6c20d5af69a29a63b530962ecbf"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0467a6c20d5af69a29a63b530962ecbf">rd_kafka_conf_set_socket_cb</a> (rd_kafka_conf_t *conf, int(*socket_cb)(int domain, int type, int protocol, void *opaque))</td></tr>
<tr class="separator:a0467a6c20d5af69a29a63b530962ecbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467bb7b1ac070fee536227d6ae9cc551"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a467bb7b1ac070fee536227d6ae9cc551">rd_kafka_conf_set_open_cb</a> (rd_kafka_conf_t *conf, int(*open_cb)(const char *pathname, int flags, mode_t mode, void *opaque))</td></tr>
<tr class="separator:a467bb7b1ac070fee536227d6ae9cc551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cb7d91d9b7458a95ca6f1292763c24"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a07cb7d91d9b7458a95ca6f1292763c24">rd_kafka_conf_set_opaque</a> (rd_kafka_conf_t *conf, void *opaque)</td></tr>
<tr class="separator:a07cb7d91d9b7458a95ca6f1292763c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af006d797a3db9c80d9bc08b2d4af93da"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#af006d797a3db9c80d9bc08b2d4af93da">rd_kafka_opaque</a> (const rd_kafka_t *rk)</td></tr>
<tr class="separator:af006d797a3db9c80d9bc08b2d4af93da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138aa4881c8703dd6b69f22ddc454f63"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a138aa4881c8703dd6b69f22ddc454f63">rd_kafka_conf_set_default_topic_conf</a> (rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf)</td></tr>
<tr class="separator:a138aa4881c8703dd6b69f22ddc454f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9f0f77e9145eb1a62c3258ac495b97"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abe9f0f77e9145eb1a62c3258ac495b97">rd_kafka_conf_get</a> (const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size)</td></tr>
<tr class="separator:abe9f0f77e9145eb1a62c3258ac495b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56939e7f77106b9e810d59289443e25d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a56939e7f77106b9e810d59289443e25d">rd_kafka_topic_conf_get</a> (const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size)</td></tr>
<tr class="separator:a56939e7f77106b9e810d59289443e25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eba851c2af748de6921d708b47dc94c"><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6eba851c2af748de6921d708b47dc94c">rd_kafka_conf_dump</a> (rd_kafka_conf_t *conf, size_t *cntp)</td></tr>
<tr class="separator:a6eba851c2af748de6921d708b47dc94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a7a88bd5ac81b21c45d1fdd4d9e696"><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a40a7a88bd5ac81b21c45d1fdd4d9e696">rd_kafka_topic_conf_dump</a> (rd_kafka_topic_conf_t *conf, size_t *cntp)</td></tr>
<tr class="separator:a40a7a88bd5ac81b21c45d1fdd4d9e696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fee1254096acd17cbd61cfe70d827e5"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8fee1254096acd17cbd61cfe70d827e5">rd_kafka_conf_dump_free</a> (const char **arr, size_t cnt)</td></tr>
<tr class="separator:a8fee1254096acd17cbd61cfe70d827e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52f3a5a08207e14386739fe336e57be"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa52f3a5a08207e14386739fe336e57be">rd_kafka_conf_properties_show</a> (FILE *fp)</td></tr>
<tr class="separator:aa52f3a5a08207e14386739fe336e57be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7032f87e7d868b80e38d0fd0ad119e"><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_topic_conf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a1a7032f87e7d868b80e38d0fd0ad119e">rd_kafka_topic_conf_new</a> (void)</td></tr>
<tr class="separator:a1a7032f87e7d868b80e38d0fd0ad119e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15de16feecd5fd5ce60e90126d83a062"><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_topic_conf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a15de16feecd5fd5ce60e90126d83a062">rd_kafka_topic_conf_dup</a> (const rd_kafka_topic_conf_t *conf)</td></tr>
<tr class="separator:a15de16feecd5fd5ce60e90126d83a062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f83e53bd89531f662644f549c85d9f"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac3f83e53bd89531f662644f549c85d9f">rd_kafka_topic_conf_destroy</a> (rd_kafka_topic_conf_t *topic_conf)</td></tr>
<tr class="separator:ac3f83e53bd89531f662644f549c85d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91b47f7733b324bf4159427e90ccd01"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac91b47f7733b324bf4159427e90ccd01">rd_kafka_topic_conf_set</a> (rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size)</td></tr>
<tr class="separator:ac91b47f7733b324bf4159427e90ccd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade099479af64ad87af7c5c6c953f18e0"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ade099479af64ad87af7c5c6c953f18e0">rd_kafka_topic_conf_set_opaque</a> (rd_kafka_topic_conf_t *conf, void *opaque)</td></tr>
<tr class="separator:ade099479af64ad87af7c5c6c953f18e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc790b5e36c56ea6d79fdc32c57becf"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abfc790b5e36c56ea6d79fdc32c57becf">rd_kafka_topic_conf_set_partitioner_cb</a> (rd_kafka_topic_conf_t *topic_conf, int32_t(*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque))</td></tr>
<tr class="separator:abfc790b5e36c56ea6d79fdc32c57becf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24c6cc7f37271e292f8105c64d77758"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad24c6cc7f37271e292f8105c64d77758">rd_kafka_topic_partition_available</a> (const rd_kafka_topic_t *rkt, int32_t partition)</td></tr>
<tr class="separator:ad24c6cc7f37271e292f8105c64d77758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8690da243d6d22f52cf8a6f0e90d7e8"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ae8690da243d6d22f52cf8a6f0e90d7e8">rd_kafka_msg_partitioner_random</a> (const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque)</td></tr>
<tr class="separator:ae8690da243d6d22f52cf8a6f0e90d7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbcab2d99882667fafa72a8deb7a6b4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#afbbcab2d99882667fafa72a8deb7a6b4">rd_kafka_msg_partitioner_consistent</a> (const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque)</td></tr>
<tr class="separator:afbbcab2d99882667fafa72a8deb7a6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d5cd86ab1f77772b2be170e1c09c24"><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24">rd_kafka_new</a> (<a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831">rd_kafka_type_t</a> type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size)</td></tr>
<tr class="separator:a63d5cd86ab1f77772b2be170e1c09c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac052e92621dcaa3a336dbf826e0d7794"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794">rd_kafka_destroy</a> (rd_kafka_t *rk)</td></tr>
<tr class="memdesc:ac052e92621dcaa3a336dbf826e0d7794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy Kafka handle.  <a href="#ac052e92621dcaa3a336dbf826e0d7794">More...</a><br/></td></tr>
<tr class="separator:ac052e92621dcaa3a336dbf826e0d7794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b15780ab1691b38b7b59e823484e1d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b15780ab1691b38b7b59e823484e1d2"></a>
RD_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a9b15780ab1691b38b7b59e823484e1d2">rd_kafka_name</a> (const rd_kafka_t *rk)</td></tr>
<tr class="memdesc:a9b15780ab1691b38b7b59e823484e1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Kafka handle name. <br/></td></tr>
<tr class="separator:a9b15780ab1691b38b7b59e823484e1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856d7ecba1aa64e5c89ac92b445cdda6"><td class="memItemLeft" align="right" valign="top">RD_EXPORT char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a856d7ecba1aa64e5c89ac92b445cdda6">rd_kafka_memberid</a> (const rd_kafka_t *rk)</td></tr>
<tr class="memdesc:a856d7ecba1aa64e5c89ac92b445cdda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this client's broker-assigned group member id.  <a href="#a856d7ecba1aa64e5c89ac92b445cdda6">More...</a><br/></td></tr>
<tr class="separator:a856d7ecba1aa64e5c89ac92b445cdda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dcba74a35e8f3bfe3270ff600581d8"><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_topic_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8">rd_kafka_topic_new</a> (rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf)</td></tr>
<tr class="memdesc:ab1dcba74a35e8f3bfe3270ff600581d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new topic handle for topic named <code>topic</code>.  <a href="#ab1dcba74a35e8f3bfe3270ff600581d8">More...</a><br/></td></tr>
<tr class="separator:ab1dcba74a35e8f3bfe3270ff600581d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f46cd29d4f9abacd3ee3633c01d8ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91f46cd29d4f9abacd3ee3633c01d8ff"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a91f46cd29d4f9abacd3ee3633c01d8ff">rd_kafka_topic_destroy</a> (rd_kafka_topic_t *rkt)</td></tr>
<tr class="memdesc:a91f46cd29d4f9abacd3ee3633c01d8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy topic handle previously created with <code><a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8" title="Creates a new topic handle for topic named topic. ">rd_kafka_topic_new()</a></code>. <br/></td></tr>
<tr class="separator:a91f46cd29d4f9abacd3ee3633c01d8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea8248521e63b4afb1d292fbcc584e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ea8248521e63b4afb1d292fbcc584e2"></a>
RD_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3ea8248521e63b4afb1d292fbcc584e2">rd_kafka_topic_name</a> (const rd_kafka_topic_t *rkt)</td></tr>
<tr class="memdesc:a3ea8248521e63b4afb1d292fbcc584e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the topic name. <br/></td></tr>
<tr class="separator:a3ea8248521e63b4afb1d292fbcc584e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022c498c5593a4bbfa978753cf250aed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a022c498c5593a4bbfa978753cf250aed"></a>
RD_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a022c498c5593a4bbfa978753cf250aed">rd_kafka_topic_opaque</a> (const rd_kafka_topic_t *rkt)</td></tr>
<tr class="memdesc:a022c498c5593a4bbfa978753cf250aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <code>rkt_opaque</code> pointer that was set in the topic configuration. <br/></td></tr>
<tr class="separator:a022c498c5593a4bbfa978753cf250aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21dcd2d8c6195baf7f9f4952d7e12d4"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4">rd_kafka_consume_start</a> (rd_kafka_topic_t *rkt, int32_t partition, int64_t offset)</td></tr>
<tr class="separator:ae21dcd2d8c6195baf7f9f4952d7e12d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e952d7961169471f69c7ddc87041258"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8e952d7961169471f69c7ddc87041258">rd_kafka_consume_start_queue</a> (rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu)</td></tr>
<tr class="separator:a8e952d7961169471f69c7ddc87041258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf07475e5e85e63fc5321a1087288cd4"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4">rd_kafka_consume_stop</a> (rd_kafka_topic_t *rkt, int32_t partition)</td></tr>
<tr class="separator:acf07475e5e85e63fc5321a1087288cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6667b162931982e9827e3d86ad22ec7d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6667b162931982e9827e3d86ad22ec7d">rd_kafka_seek</a> (rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms)</td></tr>
<tr class="separator:a6667b162931982e9827e3d86ad22ec7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49d14e8b742365f9f25d35318ff0b7e"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e">rd_kafka_consume</a> (rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms)</td></tr>
<tr class="separator:aa49d14e8b742365f9f25d35318ff0b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53511739a2cf498b8d88287fef6873ce"><td class="memItemLeft" align="right" valign="top">RD_EXPORT ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce">rd_kafka_consume_batch</a> (rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> **rkmessages, size_t rkmessages_size)</td></tr>
<tr class="separator:a53511739a2cf498b8d88287fef6873ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303fa0f0da7f3c28bed35570adc983c6"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6">rd_kafka_consume_callback</a> (rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void(*consume_cb)(<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque), void *opaque)</td></tr>
<tr class="separator:a303fa0f0da7f3c28bed35570adc983c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff0b80fccb3a5bd31b1baaf20e4ca16"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8ff0b80fccb3a5bd31b1baaf20e4ca16">rd_kafka_consume_queue</a> (rd_kafka_queue_t *rkqu, int timeout_ms)</td></tr>
<tr class="separator:a8ff0b80fccb3a5bd31b1baaf20e4ca16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d949238471993b18537855aad28fa23"><td class="memItemLeft" align="right" valign="top">RD_EXPORT ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3d949238471993b18537855aad28fa23">rd_kafka_consume_batch_queue</a> (rd_kafka_queue_t *rkqu, int timeout_ms, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> **rkmessages, size_t rkmessages_size)</td></tr>
<tr class="separator:a3d949238471993b18537855aad28fa23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1aaca2499c2e7d6da37dc28953d532"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abb1aaca2499c2e7d6da37dc28953d532">rd_kafka_consume_callback_queue</a> (rd_kafka_queue_t *rkqu, int timeout_ms, void(*consume_cb)(<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque), void *opaque)</td></tr>
<tr class="separator:abb1aaca2499c2e7d6da37dc28953d532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784186db1d2cb6ceebcd5606d38db4c4"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a784186db1d2cb6ceebcd5606d38db4c4">rd_kafka_offset_store</a> (rd_kafka_topic_t *rkt, int32_t partition, int64_t offset)</td></tr>
<tr class="separator:a784186db1d2cb6ceebcd5606d38db4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e4f88cc907347eee16ff36ab58d10e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95e4f88cc907347eee16ff36ab58d10e"></a>
RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><b>rd_kafka_produce</b> (rd_kafka_topic_t *rkt, int32_t partitition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque)</td></tr>
<tr class="separator:a95e4f88cc907347eee16ff36ab58d10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad15c71f228c47946500a0e5c6f88ed"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a7ad15c71f228c47946500a0e5c6f88ed">rd_kafka_produce_batch</a> (rd_kafka_topic_t *rkt, int32_t partition, int msgflags, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessages, int message_cnt)</td></tr>
<tr class="separator:a7ad15c71f228c47946500a0e5c6f88ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bba4a4b13fdb515f1a22d6fd4f7344"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a84bba4a4b13fdb515f1a22d6fd4f7344">rd_kafka_metadata</a> (rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms)</td></tr>
<tr class="separator:a84bba4a4b13fdb515f1a22d6fd4f7344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4ee98ab1c76f3504edf9eed986844e"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0b4ee98ab1c76f3504edf9eed986844e">rd_kafka_metadata_destroy</a> (const struct <a class="el" href="rdkafka_8h.html#a84bba4a4b13fdb515f1a22d6fd4f7344">rd_kafka_metadata</a> *metadata)</td></tr>
<tr class="separator:a0b4ee98ab1c76f3504edf9eed986844e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50c431e3a29d14da534db49bd0682a4"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4">rd_kafka_poll</a> (rd_kafka_t *rk, int timeout_ms)</td></tr>
<tr class="separator:ad50c431e3a29d14da534db49bd0682a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111628df6c84716c4b550f8509ac6a6d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a111628df6c84716c4b550f8509ac6a6d">rd_kafka_yield</a> (rd_kafka_t *rk)</td></tr>
<tr class="separator:a111628df6c84716c4b550f8509ac6a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83da8da989fe41693d78d982c7ae6b7"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab83da8da989fe41693d78d982c7ae6b7">rd_kafka_brokers_add</a> (rd_kafka_t *rk, const char *brokerlist)</td></tr>
<tr class="separator:ab83da8da989fe41693d78d982c7ae6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4af9adee414af74c7817403f7c4a53"><td class="memItemLeft" align="right" valign="top">RD_EXPORT RD_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a9e4af9adee414af74c7817403f7c4a53">rd_kafka_set_logger</a> (rd_kafka_t *rk, void(*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf))</td></tr>
<tr class="separator:a9e4af9adee414af74c7817403f7c4a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadeefced6bb60acd27e7a0dad553aa4"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#acadeefced6bb60acd27e7a0dad553aa4">rd_kafka_set_log_level</a> (rd_kafka_t *rk, int level)</td></tr>
<tr class="separator:acadeefced6bb60acd27e7a0dad553aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d37a5cef2d6aa0077fdfd23e3020ca7"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3d37a5cef2d6aa0077fdfd23e3020ca7">rd_kafka_log_print</a> (const rd_kafka_t *rk, int level, const char *fac, const char *buf)</td></tr>
<tr class="separator:a3d37a5cef2d6aa0077fdfd23e3020ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748d5eaca75f94bb4ff4217ae824385d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a748d5eaca75f94bb4ff4217ae824385d">rd_kafka_log_syslog</a> (const rd_kafka_t *rk, int level, const char *fac, const char *buf)</td></tr>
<tr class="separator:a748d5eaca75f94bb4ff4217ae824385d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b3b7659cf9a79d3353810d6b625bb7"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad4b3b7659cf9a79d3353810d6b625bb7">rd_kafka_outq_len</a> (rd_kafka_t *rk)</td></tr>
<tr class="separator:ad4b3b7659cf9a79d3353810d6b625bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a46f74ec4ccc9c0b36dbcf546908a1"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a27a46f74ec4ccc9c0b36dbcf546908a1">rd_kafka_dump</a> (FILE *fp, rd_kafka_t *rk)</td></tr>
<tr class="separator:a27a46f74ec4ccc9c0b36dbcf546908a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0901699375c972b807ba5255773f017f"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0901699375c972b807ba5255773f017f">rd_kafka_thread_cnt</a> (void)</td></tr>
<tr class="separator:a0901699375c972b807ba5255773f017f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90f2c92a382dbd0a090d40caa73356d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa90f2c92a382dbd0a090d40caa73356d">rd_kafka_wait_destroyed</a> (int timeout_ms)</td></tr>
<tr class="separator:aa90f2c92a382dbd0a090d40caa73356d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfa0a1dd3f866cbf0c82fc089bd7904"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a9bfa0a1dd3f866cbf0c82fc089bd7904">rd_kafka_poll_set_consumer</a> (rd_kafka_t *rk)</td></tr>
<tr class="memdesc:a9bfa0a1dd3f866cbf0c82fc089bd7904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirect the main (<a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4">rd_kafka_poll()</a>) queue to the KafkaConsumer's queue (<a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events. ">rd_kafka_consumer_poll()</a>).  <a href="#a9bfa0a1dd3f866cbf0c82fc089bd7904">More...</a><br/></td></tr>
<tr class="separator:a9bfa0a1dd3f866cbf0c82fc089bd7904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Queue API</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>High-level KafkaConsumer API</p>
<p>Message queues allows the application to re-route consumed messages from multiple topic+partitions into one single queue point. This queue point containing messages from a number of topic+partitions may then be served by a single rd_kafka_consume*_queue() call, rather than one call per topic+partition combination. </p>
</div></td></tr>
<tr class="memitem:a2b59178eb7e88d40510a89f3f2d98b44"><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_queue_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a2b59178eb7e88d40510a89f3f2d98b44">rd_kafka_queue_new</a> (rd_kafka_t *rk)</td></tr>
<tr class="memdesc:a2b59178eb7e88d40510a89f3f2d98b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new message queue.  <a href="#a2b59178eb7e88d40510a89f3f2d98b44">More...</a><br/></td></tr>
<tr class="separator:a2b59178eb7e88d40510a89f3f2d98b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9421b3d450f1489cf46f68d49c5ea61e"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e">rd_kafka_queue_destroy</a> (rd_kafka_queue_t *rkqu)</td></tr>
<tr class="separator:a9421b3d450f1489cf46f68d49c5ea61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">C KafkaConsumer</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>High-level KafkaConsumer API </p>
</div></td></tr>
<tr class="memitem:a0ebe15e9d0f39ccc84e9686f0fcf46f1"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0ebe15e9d0f39ccc84e9686f0fcf46f1">rd_kafka_subscribe</a> (rd_kafka_t *rk, const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *topics)</td></tr>
<tr class="memdesc:a0ebe15e9d0f39ccc84e9686f0fcf46f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe to topic set using balanced consumer groups.  <a href="#a0ebe15e9d0f39ccc84e9686f0fcf46f1">More...</a><br/></td></tr>
<tr class="separator:a0ebe15e9d0f39ccc84e9686f0fcf46f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca43b89dd1696f1d22e4e4ad49345b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ca43b89dd1696f1d22e4e4ad49345b9"></a>
RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3ca43b89dd1696f1d22e4e4ad49345b9">rd_kafka_unsubscribe</a> (rd_kafka_t *rk)</td></tr>
<tr class="memdesc:a3ca43b89dd1696f1d22e4e4ad49345b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe from the current subscriptions et. <br/></td></tr>
<tr class="separator:a3ca43b89dd1696f1d22e4e4ad49345b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66a2c014db2e652aa12466b137a6200"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab66a2c014db2e652aa12466b137a6200"></a>
RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab66a2c014db2e652aa12466b137a6200">rd_kafka_subscription</a> (rd_kafka_t *rk, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> **topics)</td></tr>
<tr class="memdesc:ab66a2c014db2e652aa12466b137a6200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current topic subscription. <br/></td></tr>
<tr class="separator:ab66a2c014db2e652aa12466b137a6200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cc6cb9bd72c4084f074af0361ceddf"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf">rd_kafka_consumer_poll</a> (rd_kafka_t *rk, int timeout_ms)</td></tr>
<tr class="memdesc:a65cc6cb9bd72c4084f074af0361ceddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll the consumer for messages or events.  <a href="#a65cc6cb9bd72c4084f074af0361ceddf">More...</a><br/></td></tr>
<tr class="separator:a65cc6cb9bd72c4084f074af0361ceddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b54d329e12d745889defe96e7d043d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a37b54d329e12d745889defe96e7d043d">rd_kafka_consumer_close</a> (rd_kafka_t *rk)</td></tr>
<tr class="memdesc:a37b54d329e12d745889defe96e7d043d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close down the KafkaConsumer.  <a href="#a37b54d329e12d745889defe96e7d043d">More...</a><br/></td></tr>
<tr class="separator:a37b54d329e12d745889defe96e7d043d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0566419eff2001f8371e3b50aa7d26e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0566419eff2001f8371e3b50aa7d26e9"></a>
RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0566419eff2001f8371e3b50aa7d26e9">rd_kafka_assign</a> (rd_kafka_t *rk, const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *partitions)</td></tr>
<tr class="memdesc:a0566419eff2001f8371e3b50aa7d26e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic assignment of partitions to consume. <br/></td></tr>
<tr class="separator:a0566419eff2001f8371e3b50aa7d26e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a00cc624a46209fe1192cfc56cce59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10a00cc624a46209fe1192cfc56cce59"></a>
RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a10a00cc624a46209fe1192cfc56cce59">rd_kafka_assignment</a> (rd_kafka_t *rk, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> **partitions)</td></tr>
<tr class="memdesc:a10a00cc624a46209fe1192cfc56cce59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current partition assignment. <br/></td></tr>
<tr class="separator:a10a00cc624a46209fe1192cfc56cce59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96539928328f14c3c9177ea0c896c87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab96539928328f14c3c9177ea0c896c87"></a>
RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab96539928328f14c3c9177ea0c896c87">rd_kafka_commit</a> (rd_kafka_t *rk, const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, int async)</td></tr>
<tr class="memdesc:ab96539928328f14c3c9177ea0c896c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit offsets on broker for the provided list of partitions. <br/></td></tr>
<tr class="separator:ab96539928328f14c3c9177ea0c896c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fb25d50216e4e20d303bf8a4a62883"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99fb25d50216e4e20d303bf8a4a62883"></a>
RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a99fb25d50216e4e20d303bf8a4a62883">rd_kafka_commit_message</a> (rd_kafka_t *rk, const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, int async)</td></tr>
<tr class="memdesc:a99fb25d50216e4e20d303bf8a4a62883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit message's offset on broker for the message's partition. <br/></td></tr>
<tr class="separator:a99fb25d50216e4e20d303bf8a4a62883"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Apache Kafka C/C++ consumer and producer client library. </p>
<p><a class="el" href="rdkafka_8h.html" title="Apache Kafka C/C++ consumer and producer client library. ">rdkafka.h</a> contains the public API for librdkafka. The API is documented in this file as comments prefixing the function, type, enum, define, etc.</p>
<dl class="section see"><dt>See Also</dt><dd>For the C++ interface see </dd>
<dd>
<a class="el" href="rdkafkacpp_8h_source.html">rdkafkacpp.h</a> </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="aed25dba90c47adc8ae51d098dca2aed9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_DEBUG_CONTEXTS&#160;&#160;&#160;&quot;all,generic,broker,topic,metadata,producer,queue,msg,protocol,cgrp,security,fetch&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported debug contexts. (compile time) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>This compile time value may be outdated at runtime due to linking another version of the library. Use <a class="el" href="rdkafka_8h.html#adece97d3cbdd6ca936df5b0663118c45" title="Retrieve supported debug contexts for use with the &quot;debug&quot; configuration property. (runtime) ">rd_kafka_get_debug_contexts()</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a21be13f8a4cb1d5aff01419f333e5ea7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_MSG_F_FREE&#160;&#160;&#160;0x1  /* Delegate freeing of payload to rdkafka. */</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce and send a single message to broker.</p>
<p>'rkt' is the target topic which must have been previously created with <code><a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8" title="Creates a new topic handle for topic named topic. ">rd_kafka_topic_new()</a></code>.</p>
<p><code>rd_kafka_produce()</code> is an asynch non-blocking API.</p>
<p>'partition' is the target partition, either:</p>
<ul>
<li>RD_KAFKA_PARTITION_UA (unassigned) for automatic partitioning using the topic's partitioner function, or</li>
<li>a fixed partition (0..N)</li>
</ul>
<p>'msgflags' is zero or more of the following flags OR:ed together: RD_KAFKA_MSG_F_FREE - rdkafka will free(3) 'payload' when it is done with it. RD_KAFKA_MSG_F_COPY - the 'payload' data will be copied and the 'payload' pointer will not be used by rdkafka after the call returns.</p>
<p>.._F_FREE and .._F_COPY are mutually exclusive.</p>
<p>If the function returns -1 and RD_KAFKA_MSG_F_FREE was specified, then the memory associated with the payload is still the caller's responsibility.</p>
<p>'payload' is the message payload of size 'len' bytes.</p>
<p>'key' is an optional message key of size 'keylen' bytes, if non-NULL it will be passed to the topic partitioner as well as be sent with the message to the broker and passed on to the consumer.</p>
<p>'msg_opaque' is an optional application-provided per-message opaque pointer that will provided in the delivery report callback (<code>dr_cb</code>) for referencing this message.</p>
<p>Returns 0 on success or -1 on error in which case errno is set accordingly: ENOBUFS - maximum number of outstanding messages has been reached: "queue.buffering.max.messages" (RD_KAFKA_RESP_ERR__QUEUE_FULL) EMSGSIZE - message is larger than configured max size: "messages.max.bytes". (RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE) ESRCH - requested 'partition' is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION) ENOENT - topic is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC)</p>
<p>NOTE: Use <code><a class="el" href="rdkafka_8h.html#a99c7d1faaa534befeedf23b55a88a40f" title="Converts the system errno value errnox to a rd_kafka_resp_err_t error code upon failure from the foll...">rd_kafka_errno2err()</a></code> to convert <code>errno</code> to rdkafka error code. </p>

</div>
</div>
<a class="anchor" id="a32dc6dd93c16e3aac9b89804c4817fba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_OFFSET_BEGINNING</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">-2  <span class="comment">/* Start consuming from beginning of</span></div>
<div class="line"><span class="comment">                       * kafka partition queue: oldest msg */</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa7aaaf16e5bd7c0a8a8cb014275c3e06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_OFFSET_END</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">-1  <span class="comment">/* Start consuming from end of kafka</span></div>
<div class="line"><span class="comment">                       * partition queue: next msg */</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a727dc7080140da43adbd5d0b170d49be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_OFFSET_STORED</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">-1000  <span class="comment">/* Start consuming from offset retrieved</span></div>
<div class="line"><span class="comment">                       * from offset store */</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3002d1858385de283ea004893e352863"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_PARTITION_UA&#160;&#160;&#160;((int32_t)-1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unassigned partition. </p>
<p>The unassigned partition is used by the producer API for messages that should be partitioned using the configured or default partitioner. </p>

</div>
</div>
<a class="anchor" id="aa2e242fb8620a32b650a40575bc7f98e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_VERSION&#160;&#160;&#160;0x000900ff</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use <a class="el" href="rdkafka_8h.html#a83e363606ef2da2e91b7429b229dbc8e" title="Returns the librdkafka version as integer. ">rd_kafka_version()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ad8306a08e59e8e2cbc6abdb84f9689f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main configuration property interface. </p>
<p>Configuration result type </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ad8306a08e59e8e2cbc6abdb84f9689f4aa1a1dc8e18c730866165853ad819054e"></a>RD_KAFKA_CONF_UNKNOWN</em>&nbsp;</td><td class="fielddoc">
<p>Unknown configuration name. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad8306a08e59e8e2cbc6abdb84f9689f4a4461e999ca6c9837a9265dad6f2a0d1e"></a>RD_KAFKA_CONF_INVALID</em>&nbsp;</td><td class="fielddoc">
<p>Invalid configuration value. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad8306a08e59e8e2cbc6abdb84f9689f4a12343fa082ab52164a17130d6b0d0f5b"></a>RD_KAFKA_CONF_OK</em>&nbsp;</td><td class="fielddoc">
<p>Configuration okay </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error codes. </p>
<p>The negative error codes delimited by two underscores (<code>RD_KAFKA_RESP_ERR__</code>..) denotes errors internal to librdkafka and are displayed as <code>"Local:</code> &lt;error string..&gt;", while the error codes delimited by a single underscore (<code>RD_KAFKA_RESP_ERR_</code>..) denote broker errors and are displayed as <code>"Broker:</code> &lt;error string..&gt;".</p>
<dl class="section see"><dt>See Also</dt><dd>Use <a class="el" href="rdkafka_8h.html#ab7bfc925e8d63851511b88a1cee94d6d" title="Returns a human readable representation of a kafka error. ">rd_kafka_err2str()</a> to translate an error code a human readable string </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba2142df2480425e88d9d96b1b08cc7c67"></a>RD_KAFKA_RESP_ERR__BEGIN</em>&nbsp;</td><td class="fielddoc">
<p>Begin internal error codes </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba807f99673a16c6dfc2d6711a142fdf63"></a>RD_KAFKA_RESP_ERR__BAD_MSG</em>&nbsp;</td><td class="fielddoc">
<p>Received message is incorrect </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba83f21df6d9e4919fa6f63f4978d92e31"></a>RD_KAFKA_RESP_ERR__BAD_COMPRESSION</em>&nbsp;</td><td class="fielddoc">
<p>Bad/unknown compression </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba9701b1e8dbfd8514773837924607985d"></a>RD_KAFKA_RESP_ERR__DESTROY</em>&nbsp;</td><td class="fielddoc">
<p>Broker is going away </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba499a09426c7317e0c8030be5bfadd6a2"></a>RD_KAFKA_RESP_ERR__FAIL</em>&nbsp;</td><td class="fielddoc">
<p>Generic failure </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaa2e905024b42d56f177547ef2c6921f2"></a>RD_KAFKA_RESP_ERR__TRANSPORT</em>&nbsp;</td><td class="fielddoc">
<p>Broker transport failure </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbad854e2c94bb5b92e83cdbe5d1b1a98ab"></a>RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE</em>&nbsp;</td><td class="fielddoc">
<p>Critical system resource </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba86ca698f5d4d99a0d61b0ec62c6ab093"></a>RD_KAFKA_RESP_ERR__RESOLVE</em>&nbsp;</td><td class="fielddoc">
<p>Failed to resolve broker </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbacb94a826892b8fef52de2c326f765172"></a>RD_KAFKA_RESP_ERR__MSG_TIMED_OUT</em>&nbsp;</td><td class="fielddoc">
<p>Produced message timed out </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaffd61f12a5298f508039a9e2521752a5"></a>RD_KAFKA_RESP_ERR__PARTITION_EOF</em>&nbsp;</td><td class="fielddoc">
<p>Reached the end of the topic+partition queue on the broker. Not really an error. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba1703a6690b6278c4ce60a7745d81c435"></a>RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION</em>&nbsp;</td><td class="fielddoc">
<p>Permanent: Partition does not exist in cluster. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba184f6fcda3fe1f6549c45f621dc456bf"></a>RD_KAFKA_RESP_ERR__FS</em>&nbsp;</td><td class="fielddoc">
<p>File or filesystem error </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbacc9b54e879dba9f6ed3c6e4492a4ae9e"></a>RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC</em>&nbsp;</td><td class="fielddoc">
<p>Permanent: Topic does not exist in cluster. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbadf1a1cc2d9244d10b5d9b2176da1a7b1"></a>RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN</em>&nbsp;</td><td class="fielddoc">
<p>All broker connections are down. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba44458ff21ab957663118decae3fe0a31"></a>RD_KAFKA_RESP_ERR__INVALID_ARG</em>&nbsp;</td><td class="fielddoc">
<p>Invalid argument, or invalid configuration </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba191a3d68aab046a25af5e861a5ce394e"></a>RD_KAFKA_RESP_ERR__TIMED_OUT</em>&nbsp;</td><td class="fielddoc">
<p>Operation timed out </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba8614bce6b6367c95e05003ed953abefa"></a>RD_KAFKA_RESP_ERR__QUEUE_FULL</em>&nbsp;</td><td class="fielddoc">
<p>Queue is full </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba35e614340fa0417a954a94d9ed252be3"></a>RD_KAFKA_RESP_ERR__ISR_INSUFF</em>&nbsp;</td><td class="fielddoc">
<p>ISR count &lt; required.acks </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbad6b23970e00b4575556e8bf6669b1907"></a>RD_KAFKA_RESP_ERR__NODE_UPDATE</em>&nbsp;</td><td class="fielddoc">
<p>Broker node update </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbafa666e504c1c4db6132bb8cc62789bd7"></a>RD_KAFKA_RESP_ERR__SSL</em>&nbsp;</td><td class="fielddoc">
<p>SSL error </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaff33cdcf5c414f862d30bfc971d9b883"></a>RD_KAFKA_RESP_ERR__WAIT_COORD</em>&nbsp;</td><td class="fielddoc">
<p>Waiting for coordinator to become available. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba34f3842df468d18d83eaf06fcb1ec133"></a>RD_KAFKA_RESP_ERR__UNKNOWN_GROUP</em>&nbsp;</td><td class="fielddoc">
<p>Unknown client group </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba3aa91f47659cd8db6e526d61bd801bb0"></a>RD_KAFKA_RESP_ERR__IN_PROGRESS</em>&nbsp;</td><td class="fielddoc">
<p>Operation in progress </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba7e8c91550c7f80e3bde03d2e2a26a13f"></a>RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS</em>&nbsp;</td><td class="fielddoc">
<p>Previous operation in progress, wait for it to finish. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba564de373d65dea2640f879b8f38032ba"></a>RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION</em>&nbsp;</td><td class="fielddoc">
<p>This operation would interfere with an existing subscription </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba4eab145a6f57f455bdde22cb94b61e90"></a>RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS</em>&nbsp;</td><td class="fielddoc">
<p>Assigned partitions (rebalance_cb) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba52a7ba59b755f419beec0433cb1633bb"></a>RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS</em>&nbsp;</td><td class="fielddoc">
<p>Revoked partitions (rebalance_cb) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbab7a5dd3646ae093462cd3bb7add5c591"></a>RD_KAFKA_RESP_ERR__CONFLICT</em>&nbsp;</td><td class="fielddoc">
<p>Conflicting use </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba6953cd96832fca9dab355a87dd83ac0d"></a>RD_KAFKA_RESP_ERR__STATE</em>&nbsp;</td><td class="fielddoc">
<p>Wrong state </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba8c92444502a2e12e78e34c293bcdd341"></a>RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL</em>&nbsp;</td><td class="fielddoc">
<p>Unknown protocol </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba8a4196c480d8dde72c14c390fe94b113"></a>RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED</em>&nbsp;</td><td class="fielddoc">
<p>Not implemented </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba87e67feaf9a884055ca195ece3ccf1c4"></a>RD_KAFKA_RESP_ERR__AUTHENTICATION</em>&nbsp;</td><td class="fielddoc">
<p>Authentication failure </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbada22593237070471d4ce1de595d1a0ae"></a>RD_KAFKA_RESP_ERR__NO_OFFSET</em>&nbsp;</td><td class="fielddoc">
<p>No stored offset </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaebda7d93e71b33ea682f2cdb2d025c0c"></a>RD_KAFKA_RESP_ERR__END</em>&nbsp;</td><td class="fielddoc">
<p>End internal error codes </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbafd4f4e867c50ec320e86871b98b7b15e"></a>RD_KAFKA_RESP_ERR_UNKNOWN</em>&nbsp;</td><td class="fielddoc">
<p>Unknown broker error </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaeb15f812641343033e3939df4adfff0a"></a>RD_KAFKA_RESP_ERR_NO_ERROR</em>&nbsp;</td><td class="fielddoc">
<p>Success </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaab466ebc9f9efcdbedfef4e57449adf4"></a>RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE</em>&nbsp;</td><td class="fielddoc">
<p>Offset out of range </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbadaaa397721f1566aa1befbb42635c6c9"></a>RD_KAFKA_RESP_ERR_INVALID_MSG</em>&nbsp;</td><td class="fielddoc">
<p>Invalid message </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba22f2b9f295640b43bbd20b064931eaa4"></a>RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART</em>&nbsp;</td><td class="fielddoc">
<p>Unknown topic or partition </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba4a78c95be9dce44441151db0f064939e"></a>RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE</em>&nbsp;</td><td class="fielddoc">
<p>Invalid message size </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba1b8fa864f8174e650a362d6c85c4acac"></a>RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Leader not available </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba48f7ea11514f0d02c090a0bf52deabb8"></a>RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION</em>&nbsp;</td><td class="fielddoc">
<p>Not leader for partition </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba1944ffe5311ce97d4f71133efd5f745f"></a>RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT</em>&nbsp;</td><td class="fielddoc">
<p>Request timed out </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba7021ad7d7486a4a33e19df226908f6f4"></a>RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Broker not available </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba550f9d64d5e2d05c61b5f18942832854"></a>RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Replica not available </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba2c5f25f8d58662c06485884c62ccd728"></a>RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE</em>&nbsp;</td><td class="fielddoc">
<p>Message size too large </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba901383ac11a5068e5cfa64fe0899ef42"></a>RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH</em>&nbsp;</td><td class="fielddoc">
<p>StaleControllerEpochCode </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbad1ace41b4944aa8510d001cc0750af3d"></a>RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE</em>&nbsp;</td><td class="fielddoc">
<p>Offset metadata string too large </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba24a154a4fd4b62b7a7fa77b816561c49"></a>RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION</em>&nbsp;</td><td class="fielddoc">
<p>Broker disconnected before response received </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba837e05b8dc24415d0cdd24fa90c94c2b"></a>RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS</em>&nbsp;</td><td class="fielddoc">
<p>Group coordinator load in progress </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba4b2032a44b39cfcf79af6d38cfee53d6"></a>RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Group coordinator not available </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbae3cca426eb84d8c987fcd22d93e3b042"></a>RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP</em>&nbsp;</td><td class="fielddoc">
<p>Not coordinator for group </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaffe696a1bb54ec33b8d258a71d138630"></a>RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION</em>&nbsp;</td><td class="fielddoc">
<p>Invalid topic </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba2427070db08c0dbf603d7a439ecafa4e"></a>RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE</em>&nbsp;</td><td class="fielddoc">
<p>Message batch larger than configured server segment size </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba963396ec3f0141e7cd64eb9103ba025a"></a>RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS</em>&nbsp;</td><td class="fielddoc">
<p>Not enough in-sync replicas </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba3c6bd5bd0a338857481157ad58701285"></a>RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND</em>&nbsp;</td><td class="fielddoc">
<p>Message(s) written to insufficient number of in-sync replicas </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba1bcf9b14d3109e0906710f3fedf6bfa0"></a>RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS</em>&nbsp;</td><td class="fielddoc">
<p>Invalid required acks value </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba7ef65ef4b7e4883d37f07edb2b9299cf"></a>RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION</em>&nbsp;</td><td class="fielddoc">
<p>Specified group generation id is not valid </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba3d611434978ee6c5d1e2c031eae22851"></a>RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL</em>&nbsp;</td><td class="fielddoc">
<p>Inconsistent group protocol </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba617af6d0a3be8be217a6d4097fe08d93"></a>RD_KAFKA_RESP_ERR_INVALID_GROUP_ID</em>&nbsp;</td><td class="fielddoc">
<p>Invalid group.id </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba98ba2fb36473df8aa20eece119b5c371"></a>RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID</em>&nbsp;</td><td class="fielddoc">
<p>Unknown member </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbacbf57dcb89cbe4e8109009235c3a38a3"></a>RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT</em>&nbsp;</td><td class="fielddoc">
<p>Invalid session timeout </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbafacbf6cd012723e9deeffdbedb086c34"></a>RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS</em>&nbsp;</td><td class="fielddoc">
<p>Group rebalance in progress </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbabce6dddfb9449a93d89f5175259b01f5"></a>RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE</em>&nbsp;</td><td class="fielddoc">
<p>Commit offset data size is not valid </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbac3ca8f351f7f49bc644360d70def9d15"></a>RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED</em>&nbsp;</td><td class="fielddoc">
<p>Topic authorization failed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaf6a3717285b4de6d098778d5abff62d3"></a>RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED</em>&nbsp;</td><td class="fielddoc">
<p>Group authorization failed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba91be303afca8631793ae36cd7fa5eb9b"></a>RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED</em>&nbsp;</td><td class="fielddoc">
<p>Cluster authorization failed </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ac6f9c3cb01cbaf3013689c4f2731b831"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831">rd_kafka_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>rd_kafka_t handle type. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24">rd_kafka_new()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ac6f9c3cb01cbaf3013689c4f2731b831ae6134e8d67bee67bfe5e90783f3b9dc8"></a>RD_KAFKA_PRODUCER</em>&nbsp;</td><td class="fielddoc">
<p>Producer client </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac6f9c3cb01cbaf3013689c4f2731b831abdc1bc1d648fb12ee3f7d42de732e049"></a>RD_KAFKA_CONSUMER</em>&nbsp;</td><td class="fielddoc">
<p>Consumer client </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab83da8da989fe41693d78d982c7ae6b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_brokers_add </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>brokerlist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds one or more brokers to the kafka handle's list of initial brokers. Additional brokers will be discovered automatically as soon as rdkafka connects to a broker by querying the broker metadata.</p>
<p>If a broker name resolves to multiple addresses (and possibly address families) all will be used for connection attempts in round-robin fashion.</p>
<p>'brokerlist' is a ,-separated list of brokers in the format: &lt;broker1&gt;,&lt;broker2&gt;,.. Where each broker is in either the host or URL based format: &lt;host&gt;[:&lt;port&gt;] &lt;proto&gt;://&lt;host&gt;[:port] &lt;proto&gt; is either PLAINTEXT or SSL. The two formats can be mixed but ultimately the value of the <code>security.protocol</code> config property decides what brokers are allowed.</p>
<p>Example: brokerlist = "broker1:10000,broker2" brokerlist = "SSL://broker3:9000,broker1:10000,ssl://broker2"</p>
<p>Returns the number of brokers successfully added.</p>
<p>NOTE: Brokers may also be defined with the 'metadata.broker.list' configuration property. </p>

</div>
</div>
<a class="anchor" id="a6eba851c2af748de6921d708b47dc94c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char** rd_kafka_conf_dump </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>cntp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the configuration properties and values of <code>conf</code> to an array with "key", "value" pairs. The number of entries in the array is returned in <code>*cntp</code>.</p>
<p>The dump must be freed with <code><a class="el" href="rdkafka_8h.html#a8fee1254096acd17cbd61cfe70d827e5">rd_kafka_conf_dump_free()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a8fee1254096acd17cbd61cfe70d827e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_dump_free </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a configuration dump returned from <code><a class="el" href="rdkafka_8h.html#a6eba851c2af748de6921d708b47dc94c">rd_kafka_conf_dump()</a></code> or `rd_kafka_topic_conf_dump(). </p>

</div>
</div>
<a class="anchor" id="a8cbfe15c6978ff09870e82cb524c673d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_conf_t* rd_kafka_conf_dup </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a copy/duplicate of configuration object 'conf'. </p>

</div>
</div>
<a class="anchor" id="abe9f0f77e9145eb1a62c3258ac495b97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a> rd_kafka_conf_get </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>dest_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve configuration value for property <code>name</code>.</p>
<p>If <code>dest</code> is non-NULL the value will be written to <code>dest</code> with at most <code>dest_size</code>.</p>
<p><code>*dest_size</code> is updated to the full length of the value, thus if <code>*dest_size</code> initially is smaller than the full length the application may reallocate <code>dest</code> to fit the returned <code>*dest_size</code> and try again.</p>
<p>If <code>dest</code> is NULL only the full length of the value is returned.</p>
<p>Returns RD_KAFKA_CONF_OK if the property name matched, else RD_KAFKA_CONF_UNKNOWN. </p>

</div>
</div>
<a class="anchor" id="aa7459bd22e8cfa81aa8c2480a4a0304c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_conf_t* rd_kafka_conf_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create configuration object. </p>
<p>When providing your own configuration to the <code>rd_kafka_*_new_*</code>() calls the rd_kafka_conf_t objects needs to be created with this function which will set up the defaults. I.e.: </p>
<div class="fragment"><div class="line">*   rd_kafka_conf_t *myconf;</div>
<div class="line">*   <a class="code" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a> res;</div>
<div class="line">*</div>
<div class="line">*   myconf = <a class="code" href="rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c">rd_kafka_conf_new</a>();</div>
<div class="line">*   res = <a class="code" href="rdkafka_8h.html#abb1b319278333e8cdee9442da7f135e8">rd_kafka_conf_set</a>(myconf, <span class="stringliteral">&quot;socket.timeout.ms&quot;</span>, <span class="stringliteral">&quot;600&quot;</span>,</div>
<div class="line">*                           errstr, <span class="keyword">sizeof</span>(errstr));</div>
<div class="line">*   <span class="keywordflow">if</span> (res != <a class="code" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4a12343fa082ab52164a17130d6b0d0f5b">RD_KAFKA_CONF_OK</a>)</div>
<div class="line">*      die(<span class="stringliteral">&quot;%s\n&quot;</span>, errstr);</div>
<div class="line">*   </div>
<div class="line">*   rk = <a class="code" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24">rd_kafka_new</a>(..., myconf);</div>
<div class="line">* </div>
</div><!-- fragment --><p>Please see CONFIGURATION.md for the default settings or use <a class="el" href="rdkafka_8h.html#aa52f3a5a08207e14386739fe336e57be">rd_kafka_conf_properties_show()</a> to provide the information at runtime.</p>
<p>The properties are identical to the Apache Kafka configuration properties whenever possible.</p>
<dl class="section return"><dt>Returns</dt><dd>A new rd_kafka_conf_t object with defaults set.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#abb1b319278333e8cdee9442da7f135e8">rd_kafka_conf_set()</a>, <a class="el" href="rdkafka_8h.html#af3669dacf78c5c0eb536d65cb45d0491" title="Destroys a conf object. ">rd_kafka_conf_destroy()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa52f3a5a08207e14386739fe336e57be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_properties_show </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a table to 'fp' of all supported configuration properties, their default values as well as a description. </p>

</div>
</div>
<a class="anchor" id="abb1b319278333e8cdee9442da7f135e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a> rd_kafka_conf_set </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>errstr_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a configuration property. 'conf' must have been previously created with <a class="el" href="rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c" title="Create configuration object. ">rd_kafka_conf_new()</a>.</p>
<p>Returns rd_kafka_conf_res_t to indicate success or failure. In case of failure 'errstr' is updated to contain a human readable error string. </p>

</div>
</div>
<a class="anchor" id="a65eaf45e9b26bcb085f4651634ce06a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_consume_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque)&#160;</td>
          <td class="paramname"><em>consume_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consumer: Set consume callback for use with <code><a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events. ">rd_kafka_consumer_poll()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a138aa4881c8703dd6b69f22ddc454f63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_default_topic_conf </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_topic_conf_t *&#160;</td>
          <td class="paramname"><em>tconf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the default topic configuration to use for automatically subscribed topics (e.g., through pattern-matched topics). The topic config object is not usable after this call. </p>

</div>
</div>
<a class="anchor" id="a075b15c4141784fdc271de217005a41f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_dr_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, void *payload, size_t len, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, void *opaque, void *msg_opaque)&#160;</td>
          <td class="paramname"><em>dr_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Producer: Set delivery report callback in provided conf object. </p>

</div>
</div>
<a class="anchor" id="ac1c9946aee26e10de2661fcf2242ea8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_dr_msg_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque)&#160;</td>
          <td class="paramname"><em>dr_msg_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Producer: Set delivery report callback in provided conf object. </p>

</div>
</div>
<a class="anchor" id="ace721ef3b7c22d0c111ec747ef039a90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_error_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, int err, const char *reason, void *opaque)&#160;</td>
          <td class="paramname"><em>error_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set error callback in provided conf object. The error callback is used by librdkafka to signal critical errors back to the application. </p>

</div>
</div>
<a class="anchor" id="a06ade2ca41f32eb82c6f7e3d4acbe19f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_log_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)&#160;</td>
          <td class="paramname"><em>log_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set logger callback. The default is to print to stderr, but a syslog logger is also available, see rd_kafka_log_(print|syslog) for the builtin alternatives. Alternatively the application may provide its own logger callback. Or pass 'func' as NULL to disable logging.</p>
<p>This is the configuration alternative to <code><a class="el" href="rdkafka_8h.html#a9e4af9adee414af74c7817403f7c4a53">rd_kafka_set_logger()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a1ab8bb9e8d8cdd5906f9e060b506f2eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_offset_commit_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, void *opaque)&#160;</td>
          <td class="paramname"><em>offset_commit_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consumer: Set offset commit callback for use with consumer groups. The results of automatic or manual offset commits will be scheduled for this callback and is served by <a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events. ">rd_kafka_consumer_poll()</a>.</p>
<p>The 'offsets' list contains per-partition information:</p>
<ul>
<li>offset: committed offset (attempted)</li>
<li>err: commit error </li>
</ul>

</div>
</div>
<a class="anchor" id="a07cb7d91d9b7458a95ca6f1292763c24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_opaque </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the application's opaque pointer that will be passed to <code>dr_cb</code> and <code>error_cb_</code> callbacks as the 'opaque' argument. </p>

</div>
</div>
<a class="anchor" id="a467bb7b1ac070fee536227d6ae9cc551"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_open_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const char *pathname, int flags, mode_t mode, void *opaque)&#160;</td>
          <td class="paramname"><em>open_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set open callback. The open callback is responsible for opening the file specified by pathname, flags and mode. The file shall be opened with CLOEXEC set in a racefree fashion, if possible.</p>
<p>Default: on linux: racefree CLOEXEC others : non-racefree CLOEXEC </p>

</div>
</div>
<a class="anchor" id="a10db731dc1a295bd9884e4f8cb199311"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_rebalance_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *partitions, void *opaque)&#160;</td>
          <td class="paramname"><em>rebalance_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consumer: Set rebalance callback for use with coordinated consumer group balancing. The 'err' field is set to either RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS or RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS and 'partitions' contains the partitions that were either assigned or revoked. </p>

</div>
</div>
<a class="anchor" id="a0467a6c20d5af69a29a63b530962ecbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_socket_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(int domain, int type, int protocol, void *opaque)&#160;</td>
          <td class="paramname"><em>socket_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set socket callback. The socket callback is responsible for opening a socket according to the supplied domain, type and protocol. The socket shall be created with CLOEXEC set in a racefree fashion, if possible.</p>
<p>Default: on linux: racefree CLOEXEC others : non-racefree CLOEXEC </p>

</div>
</div>
<a class="anchor" id="a597d00432e3ca22174d18e7e348fb766"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_stats_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)&#160;</td>
          <td class="paramname"><em>stats_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set statistics callback in provided conf object. The statistics callback is called from <code><a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4">rd_kafka_poll()</a></code> every <code>statistics.interval.ms</code> (needs to be configured separately). Function arguments: 'rk' - Kafka handle 'json' - String containing the statistics data in JSON format 'json_len' - Length of 'json' string. 'opaque' - Application-provided opaque.</p>
<p>If the application wishes to hold on to the 'json' pointer and free it at a later time it must return 1 from the <code>stats_cb</code>. If the application returns 0 from the <code>stats_cb</code> then librdkafka will immediately free the 'json' pointer. </p>

</div>
</div>
<a class="anchor" id="a04160826ad039d42c10edec456163fa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_throttle_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)&#160;</td>
          <td class="paramname"><em>throttle_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set throttle callback. The throttle callback is used in conjunction with <code>quota.support.enable=true</code> to forward broker throttle times for Produce and Fetch (consume) requests.</p>
<p>Callbacks are called whenever a non-zero throttle time is returned by the broker, or when the throttle time drops back to zero. </p>

</div>
</div>
<a class="anchor" id="aa49d14e8b742365f9f25d35318ff0b7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a>* rd_kafka_consume </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consume a single message from topic 'rkt' and 'partition'.</p>
<p>'timeout_ms' is maximum amount of time to wait for a message to be received. Consumer must have been previously started with <code><a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4">rd_kafka_consume_start()</a></code>.</p>
<p>Returns a message object on success and NULL on error. The message object must be destroyed with <code><a class="el" href="rdkafka_8h.html#a35e0c519209d1afe9e29468f766c1c24" title="Frees resources for rkmessage and hands ownership back to rdkafka. ">rd_kafka_message_destroy()</a></code> when the application is done with it.</p>
<p>Errors (when returning NULL): ETIMEDOUT - 'timeout_ms' was reached with no new messages fetched. ENOENT - 'rkt'+'partition' is unknown. (no prior <code><a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4">rd_kafka_consume_start()</a></code> call)</p>
<p>NOTE: The returned message's '..-&gt;err' must be checked for errors. NOTE: '..-&gt;err == RD_KAFKA_RESP_ERR__PARTITION_EOF' signals that the end of the partition has been reached, which should typically not be considered an error. The application should handle this case (e.g., ignore). </p>

</div>
</div>
<a class="anchor" id="a53511739a2cf498b8d88287fef6873ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT ssize_t rd_kafka_consume_batch </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> **&#160;</td>
          <td class="paramname"><em>rkmessages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rkmessages_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consume up to 'rkmessages_size' from topic 'rkt' and 'partition', putting a pointer to each message in the application provided array 'rkmessages' (of size 'rkmessages_size' entries).</p>
<p><code><a class="el" href="rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce">rd_kafka_consume_batch()</a></code> provides higher throughput performance than <code><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e">rd_kafka_consume()</a></code>.</p>
<p>'timeout_ms' is the maximum amount of time to wait for all of 'rkmessages_size' messages to be put into 'rkmessages'. If no messages were available within the timeout period this function returns 0 and <code>rkmessages</code> remains untouched. This differs somewhat from <code><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e">rd_kafka_consume()</a></code>.</p>
<p>The message objects must be destroyed with <code><a class="el" href="rdkafka_8h.html#a35e0c519209d1afe9e29468f766c1c24" title="Frees resources for rkmessage and hands ownership back to rdkafka. ">rd_kafka_message_destroy()</a></code> when the application is done with it.</p>
<p>Returns the number of rkmessages added in 'rkmessages', or -1 on error (same error codes as for <code><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e">rd_kafka_consume()</a></code>.</p>
<p>See: rd_kafka_consume </p>

</div>
</div>
<a class="anchor" id="a3d949238471993b18537855aad28fa23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT ssize_t rd_kafka_consume_batch_queue </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&#160;</td>
          <td class="paramname"><em>rkqu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> **&#160;</td>
          <td class="paramname"><em>rkmessages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rkmessages_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <code><a class="el" href="rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce">rd_kafka_consume_batch()</a></code> above. </p>

</div>
</div>
<a class="anchor" id="a303fa0f0da7f3c28bed35570adc983c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_consume_callback </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque)&#160;</td>
          <td class="paramname"><em>consume_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consumes messages from topic 'rkt' and 'partition', calling the provided callback for each consumed messsage.</p>
<p><code><a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6">rd_kafka_consume_callback()</a></code> provides higher throughput performance than both <code><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e">rd_kafka_consume()</a></code> and <code><a class="el" href="rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce">rd_kafka_consume_batch()</a></code>.</p>
<p>'timeout_ms' is the maximum amount of time to wait for one or more messages to arrive.</p>
<p>The provided 'consume_cb' function is called for each message, the application must NOT call <code><a class="el" href="rdkafka_8h.html#a35e0c519209d1afe9e29468f766c1c24" title="Frees resources for rkmessage and hands ownership back to rdkafka. ">rd_kafka_message_destroy()</a></code> on the provided 'rkmessage'.</p>
<p>The 'opaque' argument is passed to the 'consume_cb' as 'opaque'.</p>
<p>Returns the number of messages processed or -1 on error.</p>
<p>See: rd_kafka_consume </p>

</div>
</div>
<a class="anchor" id="abb1aaca2499c2e7d6da37dc28953d532"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_consume_callback_queue </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&#160;</td>
          <td class="paramname"><em>rkqu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque)&#160;</td>
          <td class="paramname"><em>consume_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <code><a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6">rd_kafka_consume_callback()</a></code> above. </p>

</div>
</div>
<a class="anchor" id="a8ff0b80fccb3a5bd31b1baaf20e4ca16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a>* rd_kafka_consume_queue </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&#160;</td>
          <td class="paramname"><em>rkqu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queue consumers</p>
<p>The following <code>..._queue()</code> functions are analogue to the functions above but reads messages from the provided queue <code>rkqu</code> instead. <code>rkqu</code> must have been previously created with <code><a class="el" href="rdkafka_8h.html#a2b59178eb7e88d40510a89f3f2d98b44" title="Create a new message queue. ">rd_kafka_queue_new()</a></code> and the topic consumer must have been started with <code><a class="el" href="rdkafka_8h.html#a8e952d7961169471f69c7ddc87041258">rd_kafka_consume_start_queue()</a></code> utilising the the same queue. See <code><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e">rd_kafka_consume()</a></code> above. </p>

</div>
</div>
<a class="anchor" id="ae21dcd2d8c6195baf7f9f4952d7e12d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_consume_start </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start consuming messages for topic 'rkt' and 'partition' at offset 'offset' which may either be an absolute (0..N) or one of the logical offsets: <code>RD_KAFKA_OFFSET_BEGINNING</code>, <code>RD_KAFKA_OFFSET_END</code>, <code>RD_KAFKA_OFFSET_STORED</code>, <code>RD_KAFKA_OFFSET_TAIL(..)</code></p>
<p>rdkafka will attempt to keep 'queued.min.messages' (config property) messages in the local queue by repeatedly fetching batches of messages from the broker until the threshold is reached.</p>
<p>The application shall use one of the <code>rd_kafka_consume*()</code> functions to consume messages from the local queue, each kafka message being represented as a <code><a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *</code> object.</p>
<p><code><a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4">rd_kafka_consume_start()</a></code> must not be called multiple times for the same topic and partition without stopping consumption first with <code><a class="el" href="rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4">rd_kafka_consume_stop()</a></code>.</p>
<p>Returns 0 on success or -1 on error in which case errno is set accordingly: EBUSY - Conflicts with an existing or previous subscription (RD_KAFKA_RESP_ERR__CONFLICT) EINVAL - Invalid offset, or incomplete configuration (lacking group.id) (RD_KAFKA_RESP_ERR__INVALID_ARG) ESRCH - requested 'partition' is invalid. (RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION) ENOENT - topic is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC)</p>
<p>Use <code><a class="el" href="rdkafka_8h.html#a99c7d1faaa534befeedf23b55a88a40f" title="Converts the system errno value errnox to a rd_kafka_resp_err_t error code upon failure from the foll...">rd_kafka_errno2err()</a></code> to convert <code>errno</code> to <code>rd_kafka_resp_err_t</code>. </p>

</div>
</div>
<a class="anchor" id="a8e952d7961169471f69c7ddc87041258"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_consume_start_queue </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_queue_t *&#160;</td>
          <td class="paramname"><em>rkqu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4">rd_kafka_consume_start()</a> but re-routes incoming messages to the provided queue 'rkqu' (which must have been previously allocated with <code><a class="el" href="rdkafka_8h.html#a2b59178eb7e88d40510a89f3f2d98b44" title="Create a new message queue. ">rd_kafka_queue_new()</a></code>. The application must use one of the <code>rd_kafka_consume_*_queue()</code> functions to receive fetched messages.</p>
<p><code><a class="el" href="rdkafka_8h.html#a8e952d7961169471f69c7ddc87041258">rd_kafka_consume_start_queue()</a></code> must not be called multiple times for the same topic and partition without stopping consumption first with <code><a class="el" href="rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4">rd_kafka_consume_stop()</a></code>. <code><a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4">rd_kafka_consume_start()</a></code> and <code><a class="el" href="rdkafka_8h.html#a8e952d7961169471f69c7ddc87041258">rd_kafka_consume_start_queue()</a></code> must not be combined for the same topic and partition. </p>

</div>
</div>
<a class="anchor" id="acf07475e5e85e63fc5321a1087288cd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_consume_stop </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop consuming messages for topic 'rkt' and 'partition', purging all messages currently in the local queue.</p>
<p>NOTE: To enforce synchronisation this call will block until the internal fetcher has terminated and offsets are commited to configured storage method.</p>
<p>The application needs to be stop all consumers before calling <code><a class="el" href="rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794" title="Destroy Kafka handle. ">rd_kafka_destroy()</a></code> on the main object handle.</p>
<p>Returns 0 on success or -1 on error (see <code>errno</code>). </p>

</div>
</div>
<a class="anchor" id="a37b54d329e12d745889defe96e7d043d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_consumer_close </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close down the KafkaConsumer. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This call will block until the consumer has revoked its assignment, calling the <code>rebalance_cb</code> if it is configured, committed offsets to broker, and left the consumer group.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An error code indicating if the consumer close was succesful or not.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The application still needs to call <a class="el" href="rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794" title="Destroy Kafka handle. ">rd_kafka_destroy()</a> after this call finishes to clean up the underlying handle resources. </dd></dl>

</div>
</div>
<a class="anchor" id="a65cc6cb9bd72c4084f074af0361ceddf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a>* rd_kafka_consumer_poll </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll the consumer for messages or events. </p>
<p>Will block for at most <code>timeout_ms</code> milliseconds. </p>

</div>
</div>
<a class="anchor" id="ac052e92621dcaa3a336dbf826e0d7794"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_destroy </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy Kafka handle. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is a blocking operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a27a46f74ec4ccc9c0b36dbcf546908a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dumps rdkafka's internal state for handle 'rk' to stream 'fp' This is only useful for debugging rdkafka, showing state and statistics for brokers, topics, partitions, etc. </p>

</div>
</div>
<a class="anchor" id="ab7bfc925e8d63851511b88a1cee94d6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char* rd_kafka_err2str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a human readable representation of a kafka error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>Error code to translate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99c7d1faaa534befeedf23b55a88a40f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_errno2err </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>errnox</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the system errno value <code>errnox</code> to a rd_kafka_resp_err_t error code upon failure from the following functions: </p>
<ul>
<li><a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8" title="Creates a new topic handle for topic named topic. ">rd_kafka_topic_new()</a></li>
<li><a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4">rd_kafka_consume_start()</a></li>
<li><a class="el" href="rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4">rd_kafka_consume_stop()</a></li>
<li><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e">rd_kafka_consume()</a></li>
<li><a class="el" href="rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce">rd_kafka_consume_batch()</a></li>
<li><a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6">rd_kafka_consume_callback()</a></li>
<li>rd_kafka_produce()</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errnox</td><td>System errno value to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Appropriate error code for <code>errnox</code> </dd></dl>

</div>
</div>
<a class="anchor" id="adece97d3cbdd6ca936df5b0663118c45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char* rd_kafka_get_debug_contexts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve supported debug contexts for use with the <code>"debug"</code> configuration property. (runtime) </p>
<dl class="section return"><dt>Returns</dt><dd>Comma-separated list of available debugging contexts. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d37a5cef2d6aa0077fdfd23e3020ca7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_log_print </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builtin (default) log sink: print to stderr </p>

</div>
</div>
<a class="anchor" id="a748d5eaca75f94bb4ff4217ae824385d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_log_syslog </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builtin log sink: print to syslog. </p>

</div>
</div>
<a class="anchor" id="a856d7ecba1aa64e5c89ac92b445cdda6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT char* rd_kafka_memberid </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns this client's broker-assigned group member id. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This currently requires the high-level KafkaConsumer</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string containing the current broker-assigned group member id, or NULL if not available. The application must free the string with <code>free()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a84bba4a4b13fdb515f1a22d6fd4f7344"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_metadata </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>all_topics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>only_rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct rd_kafka_metadata **&#160;</td>
          <td class="paramname"><em>metadatap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request Metadata from broker.</p>
<p>all_topics - if non-zero: request info about all topics in cluster, if zero: only request info about locally known topics. only_rkt - only request info about this topic metadatap - pointer to hold metadata result. The '*metadatap' pointer must be released with <a class="el" href="rdkafka_8h.html#a0b4ee98ab1c76f3504edf9eed986844e">rd_kafka_metadata_destroy()</a>. timeout_ms - maximum response time before failing.</p>
<p>Returns RD_KAFKA_RESP_ERR_NO_ERROR on success (in which case *metadatap) will be set, else RD_KAFKA_RESP_ERR__TIMED_OUT on timeout or other error code on error. </p>

</div>
</div>
<a class="anchor" id="a0b4ee98ab1c76f3504edf9eed986844e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_metadata_destroy </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="rdkafka_8h.html#a84bba4a4b13fdb515f1a22d6fd4f7344">rd_kafka_metadata</a> *&#160;</td>
          <td class="paramname"><em>metadata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release metadata memory. </p>

</div>
</div>
<a class="anchor" id="afbbcab2d99882667fafa72a8deb7a6b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rd_kafka_msg_partitioner_consistent </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg_opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consistent partitioner Uses consistent hashing to map identical keys onto identical partitions.</p>
<p>Returns a 'random' partition between 0 and partition_cnt - 1 based on the crc value of the key </p>

</div>
</div>
<a class="anchor" id="ae8690da243d6d22f52cf8a6f0e90d7e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int32_t rd_kafka_msg_partitioner_random </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg_opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Random partitioner. This is the default partitioner.</p>
<p>Returns a random partition between 0 and 'partition_cnt'-1. </p>

</div>
</div>
<a class="anchor" id="a63d5cd86ab1f77772b2be170e1c09c24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_t* rd_kafka_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831">rd_kafka_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>errstr_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new Kafka handle and starts its operation according to the specified <code>type</code> (<code>RD_KAFKA_CONSUMER</code> or <code>RD_KAFKA_PRODUCER</code>).</p>
<p><code>conf</code> is an optional struct created with <code><a class="el" href="rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c" title="Create configuration object. ">rd_kafka_conf_new()</a></code> that will be used instead of the default configuration. The <code>conf</code> object is freed by this function and must not be used or destroyed by the application sub-sequently. See <code><a class="el" href="rdkafka_8h.html#abb1b319278333e8cdee9442da7f135e8">rd_kafka_conf_set()</a></code> et.al for more information.</p>
<p><code>errstr</code> must be a pointer to memory of at least size <code>errstr_size</code> where <code><a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24">rd_kafka_new()</a></code> may write a human readable error message in case the creation of a new handle fails. In which case the function returns NULL.</p>
<dl class="section remark"><dt>Remarks</dt><dd><b>RD_KAFKA_CONSUMER:</b> When a new <code>RD_KAFKA_CONSUMER</code> rd_kafka_t handle is created it may either operate in the legacy simple consumer mode using the <a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4">rd_kafka_consume_start()</a> interface, or the High-level KafkaConsumer API. </dd>
<dd>
An application must only use one of these groups of APIs on a given rd_kafka_t RD_KAFKA_CONSUMER handle.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The Kafka handle on success or NULL on error (see <code>errstr</code>)</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>To destroy the Kafka handle, use <a class="el" href="rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794" title="Destroy Kafka handle. ">rd_kafka_destroy()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a784186db1d2cb6ceebcd5606d38db4c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_offset_store </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Topic+partition offset store.</p>
<p>If auto.commit.enable is true the offset is stored automatically prior to returning of the message(s) in each of the rd_kafka_consume*() functions above. Store offset 'offset' for topic 'rkt' partition 'partition'. The offset will be commited (written) to the offset store according to <code>auto.commit.interval.ms</code>.</p>
<p>NOTE: <code>auto.commit.enable</code> must be set to "false" when using this API.</p>
<p>Returns RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. </p>

</div>
</div>
<a class="anchor" id="af006d797a3db9c80d9bc08b2d4af93da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void* rd_kafka_opaque </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the opaque pointer previously set with <a class="el" href="rdkafka_8h.html#a07cb7d91d9b7458a95ca6f1292763c24">rd_kafka_conf_set_opaque()</a> </p>

</div>
</div>
<a class="anchor" id="ad4b3b7659cf9a79d3353810d6b625bb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_outq_len </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current out queue length: messages waiting to be sent to, or acknowledged by, the broker. </p>

</div>
</div>
<a class="anchor" id="ad50c431e3a29d14da534db49bd0682a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_poll </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Polls the provided kafka handle for events.</p>
<p>Events will cause application provided callbacks to be called.</p>
<p>The 'timeout_ms' argument specifies the minimum amount of time (in milliseconds) that the call will block waiting for events. For non-blocking calls, provide 0 as 'timeout_ms'. To wait indefinately for an event, provide -1.</p>
<p>Events:</p>
<ul>
<li>delivery report callbacks (if dr_cb is configured) [producer]</li>
<li>error callbacks (if error_cb is configured) [producer &amp; consumer]</li>
<li>stats callbacks (if stats_cb is configured) [producer &amp; consumer]</li>
</ul>
<p>Returns the number of events served. </p>

</div>
</div>
<a class="anchor" id="a9bfa0a1dd3f866cbf0c82fc089bd7904"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_poll_set_consumer </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Redirect the main (<a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4">rd_kafka_poll()</a>) queue to the KafkaConsumer's queue (<a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events. ">rd_kafka_consumer_poll()</a>). </p>
<p>Experimental APIs. </p>

</div>
</div>
<a class="anchor" id="a7ad15c71f228c47946500a0e5c6f88ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_produce_batch </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>msgflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&#160;</td>
          <td class="paramname"><em>rkmessages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>message_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce multiple messages.</p>
<p>If partition is RD_KAFKA_PARTITION_UA the configured partitioner will be run for each message (slower), otherwise the messages will be enqueued to the specified partition directly (faster).</p>
<p>The messages are provided in the array <code>rkmessages</code> of count <code>message_cnt</code> elements. The <code>partition</code> and <code>msgflags</code> are used for all provided messages.</p>
<p>Honoured <code>rkmessages[]</code> fields are: payload,len - Message payload and length key,key_len - Optional message key _private - Message opaque pointer (msg_opaque) err - Will be set according to success or failure. Application only needs to check for errors if return value != <code>message_cnt</code>.</p>
<p>Returns the number of messages succesfully enqueued for producing. </p>

</div>
</div>
<a class="anchor" id="a9421b3d450f1489cf46f68d49c5ea61e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_queue_destroy </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&#160;</td>
          <td class="paramname"><em>rkqu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a queue, purging all of its enqueued messages. </p>

</div>
</div>
<a class="anchor" id="a2b59178eb7e88d40510a89f3f2d98b44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_queue_t* rd_kafka_queue_new </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new message queue. </p>
<p>See <a class="el" href="rdkafka_8h.html#a8e952d7961169471f69c7ddc87041258">rd_kafka_consume_start_queue()</a>, <a class="el" href="rdkafka_8h.html#a8ff0b80fccb3a5bd31b1baaf20e4ca16">rd_kafka_consume_queue()</a>, et.al. </p>

</div>
</div>
<a class="anchor" id="a6667b162931982e9827e3d86ad22ec7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_seek </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Seek consumer for topic+partition to <code>offset</code> which is either an absolute or logical offset.</p>
<p>If <code>timeout_ms</code> is not 0 the call will wait this long for the seek to be performed. If the timeout is reached the internal state will be unknown and this function returns <code>RD_KAFKA_RESP_ERR__TIMED_OUT</code>. If <code>timeout_ms</code> is 0 it will initiate the seek but return immediately without any error reporting.</p>
<p>This call triggers a fetch queue barrier flush.</p>
<p>Returns <code>RD_KAFKA_RESP_ERR__NO_ERROR</code> on success else an error code. </p>

</div>
</div>
<a class="anchor" id="acadeefced6bb60acd27e7a0dad553aa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_set_log_level </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies the maximum logging level produced by internal kafka logging and debugging. If the 'debug' configuration property is set the level is automatically adjusted to LOG_DEBUG (7). </p>

</div>
</div>
<a class="anchor" id="a9e4af9adee414af74c7817403f7c4a53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT RD_DEPRECATED void rd_kafka_set_logger </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set logger function. The default is to print to stderr, but a syslog logger is also available, see rd_kafka_log_(print|syslog) for the builtin alternatives. Alternatively the application may provide its own logger callback. Or pass 'func' as NULL to disable logging.</p>
<p>DEPRECATED, use <a class="el" href="rdkafka_8h.html#a06ade2ca41f32eb82c6f7e3d4acbe19f">rd_kafka_conf_set_log_cb()</a></p>
<p>NOTE: 'rk' may be passed as NULL in the callback. </p>

</div>
</div>
<a class="anchor" id="a0ebe15e9d0f39ccc84e9686f0fcf46f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_subscribe </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>topics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribe to topic set using balanced consumer groups. </p>
<p>Wildcard (regex) topics are supported by the librdkafka assignor: any topic name in the <code>topics</code> list that is prefixed with <code>"^"</code> will be regex-matched to the full list of topics in the cluster and matching topics will be added to the subscription list. </p>

</div>
</div>
<a class="anchor" id="a0901699375c972b807ba5255773f017f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_thread_cnt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the current number of threads in use by librdkafka. Used by regression tests. </p>

</div>
</div>
<a class="anchor" id="ac3f83e53bd89531f662644f549c85d9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_topic_conf_destroy </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_conf_t *&#160;</td>
          <td class="paramname"><em>topic_conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys a topic conf object. </p>

</div>
</div>
<a class="anchor" id="a40a7a88bd5ac81b21c45d1fdd4d9e696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char** rd_kafka_topic_conf_dump </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>cntp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the topic configuration properties and values of <code>conf</code> to an array with "key", "value" pairs. The number of entries in the array is returned in <code>*cntp</code>.</p>
<p>The dump must be freed with <code><a class="el" href="rdkafka_8h.html#a8fee1254096acd17cbd61cfe70d827e5">rd_kafka_conf_dump_free()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a15de16feecd5fd5ce60e90126d83a062"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_topic_conf_t* rd_kafka_topic_conf_dup </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_topic_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a copy/duplicate of topic configuration object 'conf'. </p>

</div>
</div>
<a class="anchor" id="a56939e7f77106b9e810d59289443e25d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a> rd_kafka_topic_conf_get </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_topic_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>dest_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <code><a class="el" href="rdkafka_8h.html#abe9f0f77e9145eb1a62c3258ac495b97">rd_kafka_conf_get()</a></code> but for topic configuration objects. </p>

</div>
</div>
<a class="anchor" id="a1a7032f87e7d868b80e38d0fd0ad119e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_topic_conf_t* rd_kafka_topic_conf_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create topic configuration object</p>
<p>Same semantics as for <a class="el" href="rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c" title="Create configuration object. ">rd_kafka_conf_new()</a>. </p>

</div>
</div>
<a class="anchor" id="ac91b47f7733b324bf4159427e90ccd01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a> rd_kafka_topic_conf_set </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>errstr_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a single rd_kafka_topic_conf_t value by property name. 'topic_conf' should have been previously set up with <code><a class="el" href="rdkafka_8h.html#a1a7032f87e7d868b80e38d0fd0ad119e">rd_kafka_topic_conf_new()</a></code>.</p>
<p>Returns rd_kafka_conf_res_t to indicate success or failure. </p>

</div>
</div>
<a class="anchor" id="ade099479af64ad87af7c5c6c953f18e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_topic_conf_set_opaque </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the application's opaque pointer that will be passed to all topic callbacks as the 'rkt_opaque' argument. </p>

</div>
</div>
<a class="anchor" id="abfc790b5e36c56ea6d79fdc32c57becf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_topic_conf_set_partitioner_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_conf_t *&#160;</td>
          <td class="paramname"><em>topic_conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t(*)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)&#160;</td>
          <td class="paramname"><em>partitioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Producer: Set partitioner callback in provided topic conf object.</p>
<p>The partitioner may be called in any thread at any time, it may be called multiple times for the same message/key.</p>
<p>Partitioner function constraints:</p>
<ul>
<li>MUST NOT call any rd_kafka_*() functions except: <a class="el" href="rdkafka_8h.html#ad24c6cc7f37271e292f8105c64d77758">rd_kafka_topic_partition_available()</a></li>
<li>MUST NOT block or execute for prolonged periods of time.</li>
<li>MUST return a value between 0 and partition_cnt-1, or the special RD_KAFKA_PARTITION_UA value if partitioning could not be performed. </li>
</ul>

</div>
</div>
<a class="anchor" id="ab1dcba74a35e8f3bfe3270ff600581d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_topic_t* rd_kafka_topic_new </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_topic_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new topic handle for topic named <code>topic</code>. </p>
<p><code>conf</code> is an optional configuration for the topic created with <code><a class="el" href="rdkafka_8h.html#a1a7032f87e7d868b80e38d0fd0ad119e">rd_kafka_topic_conf_new()</a></code> that will be used instead of the default topic configuration. The <code>conf</code> object is freed by this function and must not be used or destroyed by the application sub-sequently. See <code><a class="el" href="rdkafka_8h.html#ac91b47f7733b324bf4159427e90ccd01">rd_kafka_topic_conf_set()</a></code> et.al for more information.</p>
<p>Topic handles are refcounted internally and calling <a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8" title="Creates a new topic handle for topic named topic. ">rd_kafka_topic_new()</a> again with the same topic name will return the previous topic handle without updating the original handle's configuration. Applications must eventually call <a class="el" href="rdkafka_8h.html#a91f46cd29d4f9abacd3ee3633c01d8ff" title="Destroy topic handle previously created with rd_kafka_topic_new(). ">rd_kafka_topic_destroy()</a> for each succesfull call to <a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8" title="Creates a new topic handle for topic named topic. ">rd_kafka_topic_new()</a> to clear up resources.</p>
<dl class="section return"><dt>Returns</dt><dd>the new topic handle or NULL on error (use <a class="el" href="rdkafka_8h.html#a99c7d1faaa534befeedf23b55a88a40f" title="Converts the system errno value errnox to a rd_kafka_resp_err_t error code upon failure from the foll...">rd_kafka_errno2err()</a> to convert system <code>errno</code> to an rd_kafka_resp_err_t error code.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#a91f46cd29d4f9abacd3ee3633c01d8ff" title="Destroy topic handle previously created with rd_kafka_topic_new(). ">rd_kafka_topic_destroy()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad24c6cc7f37271e292f8105c64d77758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_topic_partition_available </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if partition is available (has a leader broker).</p>
<p>Returns 1 if the partition is available, else 0.</p>
<p>NOTE: This function must only be called from inside a partitioner function. </p>

</div>
</div>
<a class="anchor" id="a123ce30e08b31d4ff0fcf6ebe876173d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a>* rd_kafka_topic_partition_list_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>rktparlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add topic+partition to list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>Topic name (copied) </td></tr>
    <tr><td class="paramname">partition</td><td>Partition id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object which can be used to fill in additionals fields. </dd></dl>

</div>
</div>
<a class="anchor" id="a6365695de425e7866ddd0c59d704111b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_topic_partition_list_add_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>rktparlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add range of partitions from <code>start</code> to <code>stop</code> inclusive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>Topic name (copied) </td></tr>
    <tr><td class="paramname">start</td><td>Start partition of range </td></tr>
    <tr><td class="paramname">stop</td><td>Last partition of range (inclusive) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66fd3f8c00ffbd0ea740a638dd0a95f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a>* rd_kafka_topic_partition_list_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a copy of an existing list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The existing list to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new list fully populated to be identical to <code>src</code> </dd></dl>

</div>
</div>
<a class="anchor" id="afb87d24333b6ad5a7415b06882f06b2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a>* rd_kafka_topic_partition_list_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new list/vector Topic+Partition container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Initial allocated size used when the expected number of elements is known or can be estimated. Avoids reallocation and possibly relocation of the elems array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated Topic+Partition list.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use <a class="el" href="rdkafka_8h.html#a0c0ab2640e5e96113ce108ab78f475d0" title="Free all resources used by the list and the list itself. ">rd_kafka_topic_partition_list_destroy()</a> to free all resources in use by a list and the list itself. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#a123ce30e08b31d4ff0fcf6ebe876173d" title="Add topic+partition to list. ">rd_kafka_topic_partition_list_add()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a83e363606ef2da2e91b7429b229dbc8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the librdkafka version as integer. </p>
<dl class="section return"><dt>Returns</dt><dd>Version integer.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>See <a class="el" href="rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e" title="librdkafka version ">RD_KAFKA_VERSION</a> for how to parse the integer format. </dd>
<dd>
Use <a class="el" href="rdkafka_8h.html#a0cc60434083686fd8e379a905652d34a" title="Returns the librdkafka version as string. ">rd_kafka_version_str()</a> to retreive the version as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="a0cc60434083686fd8e379a905652d34a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char* rd_kafka_version_str </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the librdkafka version as string. </p>
<dl class="section return"><dt>Returns</dt><dd>Version string </dd></dl>

</div>
</div>
<a class="anchor" id="aa90f2c92a382dbd0a090d40caa73356d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_wait_destroyed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for all rd_kafka_t objects to be destroyed. Returns 0 if all kafka objects are now destroyed, or -1 if the timeout was reached. Since <code><a class="el" href="rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794" title="Destroy Kafka handle. ">rd_kafka_destroy()</a></code> is an asynch operation the <code><a class="el" href="rdkafka_8h.html#aa90f2c92a382dbd0a090d40caa73356d">rd_kafka_wait_destroyed()</a></code> function can be used for applications where a clean shutdown is required. </p>

</div>
</div>
<a class="anchor" id="a111628df6c84716c4b550f8509ac6a6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_yield </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancels the current callback dispatcher (<a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4">rd_kafka_poll()</a>, <a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6">rd_kafka_consume_callback()</a>, etc).</p>
<p>A callback may use this to force an immediate return to the calling code (caller of e.g. <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4">rd_kafka_poll()</a>) without processing any further events.</p>
<p>NOTE: This function MUST ONLY be called from within a librdkafka callback. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
